/*
 * Copyright 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Adds all tasks available in the build to the task graph.
 */

import org.gradle.api.internal.GradleInternal

if (!gradle.rootBuild) {
    return
}

String SCHEDULE_ALL_TASK = "scheduleAll"

assert gradle.startParameter.dryRun : "--dry-run is required"
assert gradle.startParameter.taskNames.contains(SCHEDULE_ALL_TASK) : "A task request for `$SCHEDULE_ALL_TASK` is required"

def filtering = new Filters(
    excludedTaskNames: [
        // This happens on a simple build, but not on gradle/gradle:
        // Configuration cache state could not be cached: field `__toolchainDownloadUrls__` of task `:updateDaemonJvm` of type `org.gradle.buildconfiguration.tasks.UpdateDaemonJvm`: error writing value of type 'org.gradle.api.internal.provider.DefaultMapProperty'
        //   > Invalid task configuration
        //     Toolchain download repositories have not been configured.
        "updateDaemonJvm",
    ],
    excludedTaskTypes: [
        // https://github.com/gradle/gradle/issues/35797
        PropertyReportTask
    ],
    excludedTaskDependencies: [
        SCHEDULE_ALL_TASK,
        // avoid cycles as these are added synthetically as dependencies as well
        JavaBasePlugin.BUILD_NEEDED_TASK_NAME,
        JavaBasePlugin.BUILD_DEPENDENTS_TASK_NAME
    ]
)

Task rootAnchor = null
gradle.afterProject { Project p ->
    def created = p.tasks.register(SCHEDULE_ALL_TASK)
    created.configure { anchor ->
        if (p.rootProject != p) {
            assert rootAnchor
            rootAnchor.dependsOn(anchor)
        }
        def dependencies = project.tasks.matching { t ->
            filtering.isTaskAccepted(t) && filtering.isTaskDependencyAccepted(t)
        }
        anchor.dependsOn(dependencies)
    }
    if (p.rootProject == p) {
        rootAnchor = created.get()
    }
}

class Filters {
    List<String> excludedTaskNames = []
    List<Class<Task>> excludedTaskTypes = []
    List<String> excludedTaskDependencies = []

    def isTaskAccepted(Task toVeto) {
        return !shouldExcludeTask(toVeto.name, toVeto.class)
    }

    def isTaskDependencyAccepted(Task toVeto) {
        return !excludedTaskDependencies.contains(toVeto.name)
    }

    private boolean shouldExcludeTask(String name, Class<Task> taskType) {
        if (excludedTaskTypes.any { it.isAssignableFrom(taskType) }) {
            return true
        }
        if (excludedTaskNames.contains(name)) {
            return true
        }
        return false
    }
}
