/*
 * Copyright 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
    Realizes and optionally adds to the task graph all tasks available in the build.
 */

import org.gradle.api.internal.AbstractTask
import org.gradle.api.internal.GradleInternal
import org.gradle.api.internal.provider.ProviderInternal

import java.util.function.BiPredicate
import java.util.function.Consumer

String ANCHOR = "__anchor"

if (!gradle.rootBuild) {
    debug("Skipping ${(gradle as GradleInternal).identityPath}")
    return
}

def requestedTaskNames = gradle.startParameter.taskNames.unique()
boolean anyRequests = !requestedTaskNames.isEmpty()

debug("Originally requested tasks: ${requestedTaskNames}")

Set<String> ccIncompatibleTasks = [
    "updateDaemonJvm"
].toSet()

def filtering = new Filters()

boolean scheduleTasks = Boolean.getBoolean("scheduleTasks")
List<Task> realizedTasks = []
List<Project> allProjects = []
gradle.beforeProject { Project it ->
    debug("Collecting project $it")
    allProjects << it
}
gradle.afterProject { eachProject ->
    def realizedInProject = realizeTasks(eachProject) { p, t ->
        filtering.isProjectAccepted(p) && filtering.isTaskAccepted(t)
    }
    realizedInProject.each {
        if (ccIncompatibleTasks.contains(it.name)) {
            debug("Marking as CC incompatible: ${it.path}")
            it.notCompatibleWithConfigurationCache("Reasons")
        }
    }
    debug("Realized in $eachProject: ${realizedInProject.size()}")
    realizedInProject.each { projectTask ->
        debug("Realized: ${projectTask.name} - ${projectTask.class.simpleName}")
        realizedTasks << projectTask
    }
}

gradle.projectsEvaluated { Gradle gradle ->
    info("Realized ${realizedTasks.size()} tasks")

    if (!scheduleTasks) {
        info("Not scheduling tasks")
        return
    }
    if (!anyRequests) {
        gradle.rootProject.defaultTasks = [ANCHOR]
    }

    info("Looking for tasks to schedule - considering ${allProjects.size()} projects")
    // Build the list of requested Task objects (from names)
    def requestedTasks= toRequestedTasks(gradle.rootProject, requestedTaskNames)
    debug("Resolved requested tasks: ${requestedTasks.size()} of ${requestedTasks}")
    // Build the list of requested Task objects (from names)
    List<String> requestedTaskPaths = requestedTasks*.path

    // create a root anchor task
    def rootAnchor = gradle.rootProject.tasks.register(ANCHOR).get()
    rootAnchor.configure { task ->
        if (anyRequests) {
            requestedTasks[0].finalizedBy(task)
        }
    }
    // create anchor tasks for every subproject
    Map<String, Task> anchorsPerProject = [":":rootAnchor]
    allProjects.each {project ->
        debug("Evaluating $project")
        if (project == gradle.rootProject) {
            debug("Skipping $project")
            return
        }
        def projectAnchor = project.tasks.register(ANCHOR, {
            if (anyRequests) {
                rootAnchor.dependsOn(it)
            }
        }).get()
        debug("Registering ${projectAnchor.path} under ${project.path} on ${System.identityHashCode(anchorsPerProject)}")
        anchorsPerProject[project.path] = projectAnchor
    }

    // Ensure tasks not explicitly requested are added to the task graph
    def tasksToAddTaskGraph = realizedTasks.findAll { filtering.isTaskAccepted(it) }
    debug("tasksToAddTaskGraph:") {
        tasksToAddTaskGraph.collect { "${it.name} (${it.class.name})" }
    }
    debug("exceptions:") {
        realizedTasks.findAll { !filtering.isTaskAccepted(it) }
    }
    def tasksNotInTaskGraphYet = tasksToAddTaskGraph.findAll {!requestedTaskPaths.contains(it.path) }
    debug("tasksNotInTaskGraphYet: ${tasksNotInTaskGraphYet.size()}")
    def tasksToAddByProjectPath = tasksNotInTaskGraphYet.groupBy { it.project.path }
    info("Adding ${tasksNotInTaskGraphYet.size()} new tasks to task graph")
    tasksToAddByProjectPath.each { projectPath, tasksInProject ->
        def filteredTasks = tasksInProject.findAll { filtering.isTaskDependencyAccepted(it) }
        def projectAnchor = anchorsPerProject[projectPath]
        debug("Anchor for $projectPath : $projectAnchor")
        debug("Adding ${filteredTasks.size()} tasks to $projectPath")
        filteredTasks.each {
            debug(" - ${it.name}")
        }
        projectAnchor.dependsOn(filteredTasks)
    }
    // disable all tasks in the graph in case the user did not request --dry-run
    taskGraph.whenReady { graph ->
        def allTasks = graph.allTasks
        info("Disabling task execution on ${allTasks.size()} tasks")
        allTasks.each {
            debug("Disabling ${it.path}")
            it.setEnabled(false)
        }
    }
}

List<Task> toRequestedTasks(Project rootProject, List<String> names) {
    return names.collect {
        def task = rootProject.tasks.findByPath(it)
        if (task == null) {
            throw new IllegalArgumentException("Could not find a task for $it")
        }
        task
    }.unique()
}

def realizeTasks(Project project, BiPredicate<Project, TaskProvider> condition) {
    return project.tasks.names.collect { name ->
        TaskProvider taskProvider = project.tasks.named(name)
        boolean shouldRealize = condition.test(project, taskProvider)
        return shouldRealize ?
            taskProvider.get() : null
    }.findAll()
}

void debug(String message, Closure lazyValue = null) {
    log(message, lazyValue) {
        logger.info(it)
    }
}

void info(String message, Closure lazyValue = null) {
    log(message, lazyValue) {
        println(it)
    }
}

private void log(String message, Closure lazyValue, Consumer<String> consumer) {
    consumer.accept("*** " + message)
    lazyValue?.tap {
        consumer.accept("*** " + it.call())
    }
}

class Filters {
    def isTaskAccepted(TaskProvider task) {
        return !shouldExcludeTask(task.name, ((ProviderInternal) task).type)
    }

    def isTaskAccepted(Task task) {
        return !shouldExcludeTask(task.name, task.class) && (task as AbstractTask).compatibleWithConfigurationCache
    }

    private boolean shouldExcludeTask(String name, Class<Task> taskType) {
        def taskTypeExclusions = [
            // https://github.com/gradle/gradle/issues/35797
            PropertyReportTask
        ]
        def taskNameExclusions = [
            // Leads to afterEvaluate to be invoked in the context of task realization
            // https://github.com/gradle/gradle/issues/35797
            "checkBinaryCompatibility"
        ]
        if (taskTypeExclusions.any { it.isAssignableFrom(taskType) }) {
            return true
        }
        if (taskNameExclusions.contains(name)) {
            return true
        }
        return false
    }

    def isTaskDependencyAccepted(Task toVeto) {
        def exclusions = [
            // to avoid cycles as these are added synthetically as dependencies as well
            JavaBasePlugin.BUILD_NEEDED_TASK_NAME,
            JavaBasePlugin.BUILD_DEPENDENTS_TASK_NAME
        ]
        return !exclusions.contains(toVeto.name)
    }

    def isProjectAccepted(Project project) {
        // add any projects to be excluded here
        def toExclude = [
        ]
        return !toExclude.contains(project.path)
    }
}

