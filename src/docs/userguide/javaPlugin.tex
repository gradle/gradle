%!TEX root = master.tex
\chapter{The Java Plugin} % (fold)
\label{cha:the_java_plugin}
Table \ref{javalayout} shows the default project layout assumed by the Java Plugin. This is configurable via the convention object. Table \ref{javatasks} shows the tasks added by the Java Plugin. These tasks constitute a lifecycle for Java builds. Table \ref{javaconventionDir} and Table \ref{javaconventionNonDir} shows the most important properties of the convention object of the Java plugin.\footnote{The \emph{buildDir} property is a property of the project object. It defaults to \texttt{build}.} Gradle's conventions contain a convention for the directory hierarchy as well as conventions for the element names of the hierarchy. For example the \texttt{srcDirs} are relative to the \texttt{srcRoot}. Therefore \texttt{srcDirs} is a read-only property. If you want to change the name of the source dirs you need to do this via the \texttt{srcDirNames} property. But the paths you specify here are \emph{relative} to the \texttt{srcRoot}. This has the advantage to make bulk changes easy. If you change \texttt{srcRoot} from \texttt{src} to \texttt{source}, this automatically applies to all directory properties which are relative to \texttt{srcRoot}. As this also introduces an inflexibility, we have additional floating dirs, which are not bound to any hierarchy (see Table \ref{javaconventionFloatingDir}). For example code generation tool could make use of this, by adding a source dir which is located in the build folder.

\begin{table}
	\begin{center}
	\begin{tabular}{|l|l|} \hline
	\textbf{Folder} & \textbf{Meaning} \\ \hline
	\texttt{src/main/java} & Application/Library sources \\ \hline
	\texttt{src/main/resources} & Application/Library resources \\ \hline
	\texttt{src/main/webapp} & Web application sources \\ \hline
	\texttt{src/test/java} & Test sources \\ \hline
	\texttt{src/test/resources} & Test resources \\ \hline
	\end{tabular}
	\end{center}
	\caption{Default Directory Layout}	
	\label{javalayout}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Taskname} & \textbf{dependsOn} & \textbf{Type} \\ \hline
			clean & - & org.gradle.api.tasks.Clean \\ \hline
			javadoc & - & org.gradle.api.tasks.Javadoc \\ \hline
			init & - & org.gradle.api.tasks.DefaultTask \\ \hline
			resources & initialize & org.gradle.api.tasks.Resources \\ \hline
			compile & resources & org.gradle.api.tasks.compile.Compile \\ \hline
			testResources & compile & org.gradle.api.tasks.Resources \\ \hline
			testCompile & testResources & org.gradle.api.tasks.compile.Compile \\ \hline
			test & testCompile & org.gradle.api.tasks.testing.Test \\ \hline
			libs & test & org.gradle.api.tasks.bundling.Bundle \\ \hline
			uploadLibs & libs & org.gradle.api.tasks.Upload \\ \hline
			dists & uploadLibs & org.gradle.api.tasks.bundling.Bundle \\ \hline
			uploadDists & dists & org.gradle.api.tasks.Upload \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Plugin Tasks}	
	\label{javatasks}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|l|} \hline
			\textbf{Dir Name} & \textbf{Dir File} & \textbf{Default Value Name} & \textbf{Default Value File}\\ \hline
			srcRootName & srcRoot & \texttt{src} & \emph{projectDir}\texttt{/src}\\ \hline
			srcDirNames & srcDirs & \texttt{main/java} & [\emph{srcRoot}\texttt{/main/java}] \\ \hline
			resourceDirNames & resourceDirs & \texttt{main/resources} & [\emph{srcRoot}\texttt{/main/resources}]\\ \hline
			testSrcDirNames & testSrcDirs & \texttt{test/java} & [\emph{srcRoot}\texttt{/test/java}] \\ \hline
			testResourceDirNames & testResourceDirs & \texttt{main/resources} & [\emph{srcRoot}\texttt{/main/resources}] \\ \hline
			srcDocsDirName & srcDocsDir & \texttt{docs} & \emph{srcRoot}\texttt{/docs} \\ \hline
			classesDirName & classesDir & \texttt{classes} & \emph{buildDir}\texttt{/classes} \\ \hline
			testClassesDirName & testClassesDir & \texttt{test-classes} & \emph{buildDir}\texttt{/test-classes} \\ \hline
			testResultsDir & testResultsDirName & \texttt{test-results} & \emph{buildDir}\texttt{/test-results} \\ \hline
			distsDirName & distsDir & \texttt{dists} & \emph{buildDir}\texttt{/dists} \\ \hline
			docsDirName & docsDir & \texttt{docs} & \emph{buildDir}\texttt{/docs} \\ \hline
			javadocDirName & javadocDir & \texttt{javadoc} & \emph{buildDir}\texttt{/javadoc} \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Directory Hierarchy Properties}
	\label{javaconventionDir}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Property} & \textbf{Type} & \textbf{Default Value} \\ \hline
			floatingSrcDirs & List & empty \\ \hline
			floatingResourceDirs & List & empty \\ \hline
			floatingTestResourceDirs & List & empty \\ \hline
			floatingTestResourceDirs & List & empty \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Floating Dir Properties}
	\label{javaconventionFloatingDir}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Property} & \textbf{Type} & \textbf{Default Value} \\ \hline
			sourceCompatibility & String & \texttt{null} \\ \hline
			targetCompatibility & String & \texttt{null} \\ \hline
			manifest & GradleManifest & empty \\ \hline
			metaInf & List & empty \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Non Dir Properties}
	\label{javaconventionNonDir}
\end{table}

\section{Init} % (fold)
\label{sec:initialization}
The \texttt{init} task has no default action attached to it. It is meant to be a hook. You can add actions to it or associates your custom tasks with it. The Java Plugin executes this task before any other of its tasks get executed (except \texttt{clean} and \texttt{javadoc} which does not depends on \texttt{init}).
% section initialization (end)

\section{Javadoc} % (fold)
\label{sec:javadoc}
The \texttt{javadoc} task has no default association with any other task. It has no prerequisites on the actions of other tasks, as it operates on the source. It does not provide a fine-grained configuration API yet. If you need this, you have to use for example Ant's javadoc task directly.
\begin{center}
	\begin{tabular}{|l|l|} \hline
		\multicolumn{2}{|c|}{Convention to Property Mapping} \\ \hline
	    \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		srcDirs & srcDirs \\ \hline
		destinationDir & [javadocDir] \\ \hline
	\end{tabular} 
\end{center} 
% section javadoc (end)

\section{Clean} % (fold)
\label{sec:clean}
The \texttt{clean} task simply removes the directory denoted by its \texttt{dir} property. This property is mapped to the \texttt{buildDir} property of the project. In future releases there will be more control of what gets deleted. If you need more control now, you can use the \emph{Ant delete task}.  
% section clean (end)

\section{Resources} % (fold)
\label{sec:resources}
The \emph{Resources} task has two instances, \texttt{resources} and \texttt{testResources}. 
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		resources & sourceDirs & resourceDirs \\ \hline
		resources & destinationDir & classesDir \\ \hline
		testResources & sourceDirs & testResourceDirs \\ \hline
		testResources & destinationDir & testClassesDir \\ \hline
	\end{tabular} 
\end{center}
\noindent The \texttt{resources} task offers includes and excludes directives as well as filters. Have a look at \href{\API tasks/Resources.html}{org.gradle.api.tasks.Resources} to learn about the details.
% section resources (end)

\section{Compile} % (fold)
\label{sec:compile}
The \emph{Compile} task has two instances, \texttt{compile} and \texttt{testCompile}. 
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		compile & srcDirs & srcDirs \\ \hline
		compile & destinationDir & classesDir \\ \hline
		compile & sourceCompatibility & sourceCompatibility \\ \hline
		compile & targetCompatibility & targetCompatibility \\ \hline
		testCompile & srcDirs & testSrcDirs \\ \hline
		testCompile & destinationDir & testClassesDir \\ \hline
		testCompile & sourceCompatibility & sourceCompatibility \\ \hline
		testCompile & targetCompatibility & targetCompatibility \\ \hline
	\end{tabular} 
\end{center}
\noindent The classpath of the compile task is derived from two sources. One is the \emph{configuration} assigned to the task by the dependency manager. The other classpath source is the \texttt{unmanagedClasspath} property: a list of files denoting a jar or a directory. Usually you create your classpath with the dependency manager. The \texttt{unmanagedClasspath} is used internally by Gradle. This classpath is not shared between projects in a multi-project build. Nor is it part of a dependency descriptor if you choose to upload your library to a repository. 
See section \ref{} how the JavaPlugin glues the tasks with the dependency manager and see the whole chapter \ref{cha:dependency_management} how to use the dependency manager.

Have a look at \href{\API tasks/compile/Compile.html}{org.gradle.api.tasks.compile.Compile} to learn about the details. The compile task delegates to Ants javac task to do the compile. Via the compile task you can set most of the properties of Ants javac task. 
% section compile (end)

\section{Test} % (fold)
\label{sec:test}
The \texttt{test} task executes the unit tests which have been compiled by the \texttt{testCompile} task. 
\begin{center}
	\begin{tabular}{|l|l|} \hline
		\multicolumn{2}{|c|}{Convention to Property Mapping} \\ \hline
	    \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		testClassesDir & testClassesDir \\ \hline
		testResultsDir & testResultsDir \\ \hline
		unmanagedClasspath & [classesDir] \\ \hline
	\end{tabular} 
\end{center}
\noindent Have a look at \href{\API tasks/testing/Test.html}{org.gradle.api.tasks.testing.Test} to learn more. Right now the test results are always in XML-format. The task has a \texttt{stopAtFailuresOrErrors} property to control the behavior when tests are failing. The task \emph{always} executes all the tests and afterwards stops the build if this property is true and there are failing tests or tests that have thrown an uncaught exception. The test task delegates to Ants junit task. TestNG is not supported yet. You can expect TestNG support with our next release. 
% section test (end)

\section{Bundles} % (fold)
\label{sec:bundles}
The \emph{Bundle} task has two instances, \texttt{libs} and \texttt{dists}. The Bundle task is a special animal. It is a container for archive tasks (jar, zip, ...).  
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		libs & tasksBaseName & \texttt{project.archivesBaseName} \\ \hline
		dists & tasksBaseName & \texttt{project.archivesBaseName} \\ \hline
	\end{tabular} 
\end{center}
\subsection{The libs Task} % (fold)
\label{sub:the_libs_task}
The \texttt{libs} task contains all the archive tasks which constitute the libraries needed to use your project as a library. Executing the libs task leads to the execution of all the contained archive tasks. In a multi-project build the archives which are produced by the \texttt{libs} task are available in the classpath of a dependent project. If you upload your project into a repository, those archives are part of the dependency descriptor. If you come from Maven you can have only one library jar per project. With Ivy you can have as many as you want. 
The Java plugin adds by default one jar archive to the \texttt{libs} task. The task name is by default \texttt{projectName\_jar} and can of course be manipulated by this name. This jar contains the content of the \texttt{classesDir}. This is the behavior your are used from Maven. If you are happy with that you usually don't have to touch this task. Except if you want to change the names of the generated archives. 

The \texttt{libs} task depends on the \texttt{test} task and its archive tasks. The archive tasks assigned to the \texttt{libs} task depend by default on the \texttt{test} task as well. You can change this via the \texttt{childrenDependsOn} property of the \texttt{libs} task. 
% subsection the_libs_task (end)
\subsection{The dists Task} % (fold)
\label{sub:the_dists_task}
The \texttt{dists} task contains all the archive task that make up your distributions. For example a binary and a source distribution. The \texttt{dists} task has two purposes. One is providing a hook for distributions in the lifecycle. The other is for uploading distribution archives (the same is also true for the \texttt{libs} task.) The \texttt{dists} task depends on its archive tasks and the \texttt{libs} task. The contained archive tasks depend by default on the \texttt{libs} task as well. You can change this via the \texttt{childrenDependsOn} property of the \texttt{dists} task. 
% subsection the_dis (end)
\subsection{Adding Archives} % (fold)
\label{sub:adding_archives}
The Bundle task has a couple of convenience methods for adding new archive tasks to it. Right now there are the methods (\texttt{jar}, \texttt{war}, \texttt{zip}, \texttt{tar}, \texttt{tarGz}, \texttt{tarBzip2}). They all behave in the same way.
\begin{Verbatim}
usePlugin('java')
archivesBaseName = gradle // defaults to project.name
version = 1.0
dists {
    zip() {
        fileSet(dir: 'somedir')
    }
}	
gradle_zip.baseName = 'i_am_special' // Now the generated archive will be: i_am_special-1.0.zip
\end{Verbatim}
This adds an archive task with the name \texttt{gradle\_zip}. It is important to distinguish between the name of the archive task and the name of the archive generated by the archive task. The latter can be changed at any time later on and is by default \texttt{gradle-1.0.zip}. You can pass a closure to the \texttt{zip()} method, which statements are applied against the newly created archive task object. In section \ref{sec:archive_tasks} you will learn more about which statements you can apply against a particular archive task.
\begin{Verbatim}
dists {
    zip(baseName: 'craidle', classifier: 'src') {
        fileSet(dir: 'somedir')
    }
}
\end{Verbatim}
You can pass also optionally pass arguments to the \texttt{zip()} method. In this example we create an archive task with the name \texttt{craidle\_src\_zip} which generates an archive with the name \texttt{craidle-1.0-src.zip}. 
% subsection adding_archives (end)

\section{Archive Tasks} % (fold)
\label{sec:archive_tasks}
An archive task is a task which produces an archive at execution time. The following archives tasks are available:
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		Type & Accepted file container & Extends \\ \hline
		\href{\API tasks/bundling/Zip.html}{org.gradle.api.tasks.bundling.Zip} & fileSet, fileCollection, zipFileSet & AbstractArchiveTask \\ \hline
		\href{\API tasks/bundling/Tar.html}{org.gradle.api.tasks.bundling.Tar} & fileSet, fileCollection, zipFileSet, tarFileSet & Zip \\ \hline
		\href{\API tasks/bundling/Jar.html}{org.gradle.api.tasks.bundling.Jar} & fileSet, fileCollection, zipFileSet & Zip \\ \hline
		\href{\API tasks/bundling/War.html}{org.gradle.api.tasks.bundling.War} & fileSet, fileCollection, zipFileSet & Jar \\ \hline		
	\end{tabular}
\end{center}
The following file containers are available:
\begin{table}
\begin{center}
\begin{tabularx}{\textwidth}{|l|X|} \hline
		Type & Meaning \\ \hline
		\href{\API tasks/util/FileSet.html}{org.gradle.api.tasks.util.FileSet} & A set of files defined by a common baseDir and include/exclude patterns. \\ \hline
		\href{\API tasks/util/ZipFileSet.html}{org.gradle.api.tasks.util.ZipFileSet} & Extends FileSet with additional properties known from Ants zipfileset task.\\ \hline
	    \href{\API tasks/util/TarFileSet.html}{org.gradle.api.tasks.util.TarFileSet} & Extends ZipFileSet with additional properties known from Ants tarfileset task.\\ \hline
		\href{\API tasks/util/FileCollection.html}{org.gradle.api.tasks.util.FileCollection} & An arbitrary collection of files to the archive. In contrast to a FileSet they don't need to have a common basedir.\\ \hline
	    \href{\API tasks/util/AntDirective.html}{org.gradle.api.tasks.util.AntDirective} & An arbitrary Ant resource declaration.\\ \hline	
\end{tabularx}
\end{center}
	\caption{Filecontainer for Archives}
	\label{filecontainer}
\end{table}
To learn about all the details have a look at the javadoc of the archive task class or the file container class itself.
\subsection{Common Properties} % (fold)
\label{sub:common_properties}
The name of the generated archive is assembled from the task properties \texttt{baseName}, \texttt{classifier} and \texttt{extension} to: \texttt{baseName-project.version-classifier.extension}.\footnote{If the classifier is empty the trailing \texttt{-} is not added to the name. The same is true for the \texttt{project.version} property}. The assembled name is accessible via the \texttt{archiveName} property. The \texttt{name} property denotes the name of the task, not the generated archive. An archive task has also a \texttt{customName} property. If this property is set, the \texttt{archiveName} property returns its value instead of assembling a name out of the properties mentioned above.

Archives have a \texttt{destinationDir} property to specify where the generated archive should be placed. It has also an \texttt{archivePath} property, which returns a File object with the absolute path of the generated archive.
% subsection common_properties (end)

\subsection{Adding Content} % (fold)
\label{sub:adding_content}
To add content to an archive you must add file container to an archive (see Table \ref{filecontainer}). You can add as many file container as you like. They behave pretty much the same as the Ant resources with similar names. 
\begin{Verbatim}
myZipTask.fileSet(dir: 'contentDir') {
	include('**/*.txt')
	exclude('**/*.gif')
}
\end{Verbatim}
You can add arbitrary files to an archive:
\begin{Verbatim}
myZipTask.files('path_to_file1', 'path_to_file2')
\end{Verbatim}
Other examples:
\begin{Verbatim}
myZipTask.zipFileSet(dir: 'contentDir') {
	include('**/*.txt')
	exclude('**/*.gif')
	prefix = 'myprefix'
}
\end{Verbatim}

\begin{Verbatim}
myTarTask.tarFileSet(dir: 'contentDir') {
	include('**/*.txt')
	exclude('**/*.gif')
	uid = 'myuid'
}
\end{Verbatim}
There is also the option to add an arbitrary Ant expression describing an Ant resource.
\begin{Verbatim}
myZipTask.antDirective {        
   zipgroupfileset(dir: new File(rootDir, 'lib'))    
}
\end{Verbatim}
This is for rather exotic use cases. Usually you should be fine with the file container provided by Gradle.  
% subsection adding_content (end)

\subsection{Merging} % (fold)
\label{sub:merging}
If you want to merge the content of other archives into the archive to be generated Gradle offers you two methods. One is \texttt{merge}:
\begin{Verbatim}
myZipTask.merge('path1/otherArchive1.zip', 'path2/otherArchive.tar.gz')
\end{Verbatim} 
This merges the whole content of the archive passed to the merge method into the generated archive. If you need more control which content of the archive should be merged and to what path, you can pass a closure to the merge method:
\begin{Verbatim}
myZipTask.merge('path1/otherArchive1.zip', 'path2/otherArchive.tar.gz') {
	include('**/*.txt')
	exclude('**/*.gif')
	prefix = 'myprefix'
}
\end{Verbatim}
Under the hood Gradle scans the extension of the archives to be merged. According to the extension, it creates a \texttt{ZipFileSet} or \texttt{TarFileSet}. The closure is applied to this newly created file container.  
\\
\noindent There is another method for merging called \texttt{mergeGroup}.
\begin{Verbatim}
myZipTask.mergeGroup('path_to_dir_with_archives') {
	include('**/*.zip')
	exclude('**/*.tar.gz')
}
\end{Verbatim}
With this method you can assign a set of archives to be merged. Those archives have to be located under the directory you pass as an argument. You can define filters what archives should be included. They are always included fully and you can't specify a path. If you need this features, you must use the \texttt{merge} method.  
% subsection merging (end)
\subsection{Manifest} % (fold)
\label{sub:manifest}
The convention object of the JavaPlugin has a \texttt{manifest} property pointing to an instance of \href{\API tasks/bundling/GradleManifest.html}{org.gradle.api.bundling.GradleManifest}. With this \texttt{GradleManifest} object you can define the content of the \texttt{MANIFEST.MF} file of all the jar or a war archives in your project. 
\begin{Verbatim}
manifest.mainAttributes(Implementation-Title: "Gradle", Implementation-Version: $version)
\end{Verbatim}
You can also define sections of a manifest file.

If a particular archive needs unique entries in its manifest you have to create an own \texttt{GradleManifest} object for it.
\begin{Verbatim}
manifest.mainAttributes(Implementation-Title: "Gradle", Implementation-Version: $version)
myZipTask.manifest = new GradleManifest(manifest)
myZipTask.manifest.mainAttributes(mykey: "myvalue")
\end{Verbatim} 
Passing the common manifest object to the constructor of \texttt{GradleManifest} add the common manifest values to the task specific manifest instance.
% subsection manifest (end)

\subsection{MetaInf} % (fold)
\label{sub:metainf}
The convention object of the JavaPlugin has a \texttt{metaInf} property pointing to a list of \texttt{FileSet} objects. With this file sets you can define which files should be in the META-INF directory of a jar or a war archive. 
\begin{Verbatim}
metaInf << new FileSet(someDir)
\end{Verbatim}
% subsection archive_tasks (end)

\section{Upload} % (fold)
\label{sec:upload}
The \emph{Upload} task has two instances, \texttt{uploadLibs} and \texttt{uploadDists}. An easy way of describing there behavior, is that all archives added to the \texttt{libs} and \texttt{dists} bundle are uploaded by the corresponding upload task. An upload task uploads to the repositories assigned to it. If needed you have more control on what files get uploaded. Have a look at \href{\API tasks/Upload.html}{org.gradle.api.tasks.Upload} to learn more.
% section upload (end)
% section metainf_and_manifest (end)
% chapter the_java_plugin (end)
