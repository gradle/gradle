%!TEX root = master.tex
\chapter{The Project and Task API} % (fold)
\label{cha:the_project_and_task_api}

\section{Project API} % (fold)
\label{sec:project_api}
In the tutorial in chapter \ref{cha:gradle_core_tutorial} we have called for example the method \texttt{createTask}. Where does this method come from? We said earlier that the directory containing the build script defines a project for Gradle. For Gradle this means, that it creates an instance of \texttt{org.gradle.api.Project} and associates it with the build script. With the build script you can configure this project object.
\begin{itemize}
	\item Any method you call in your build script, which \emph{is not defined} in the build script, is delegated to the project object.
	\item Any property you access in your build script, which \emph{is not defined} in the build script, is delegated to the project object.
\end{itemize}
Let's try this out and try to access the \texttt{name} property of the Project object.
\codeInput{../../samples/userguide/tutorial/projectApi.gradle}
\outputInputTutorial{../../samples/userguideOutput/projectApi.out}
Both \texttt{println} statements print out the same property. One uses the auto delegation to the project object, for properties not defined in the build script. The other statement uses the \texttt{project} property available to any build script, which provides an instance of the associated project object. Only if you define a property or a method which has the same name as a member of the project object, you need to use the \texttt{project} property. Look here to learn more about \href{\API Project.html}{org.gradle.api.Project}.
% section project_api (end)
\section{Task API} % (fold)
\label{sec:task_api}
Many of the methods of the project object return task objects. We have already seen some ways on how to use the task objects in chapter \ref{cha:gradle_core_tutorial}. Look here to learn more about \href{\API Task.html}{org.gradle.api.Task}.
% section task_api (end)
\section{Summary} % (fold)
\label{sec:summary}
The project and the task API constitute the core layer of Gradle and provide all the possible interaction options with this layer.\footnote{There is more to come for this layer in the other chapters, e.g. support for multi-project builds (see chapter \ref{cha:multi_project_builds}).} This core-layer constitutes a language for dependency based programming.\footnote{Martin Fowler has written about this: \url{http://martinfowler.com/articles/rake.html\#DependencyBasedProgramming}} There are many other projects providing such a language. There is Ant for Java, Rake and Rant for Ruby, SCons for Python, the good old Make and many more.\footnote{Interestingly, Maven2 is the only major build system which does not use dependency based programming.} We think that one thing that makes Gradle special compared to the other tools, is its strong support for applying dependency based programming on \texttt{multiproject} builds. We also think that just Gradles core layer (together with its integration of the Ant tasks), provides a more convenient build system than Ant's core layer.
% section summary (end)

% chapter the_project_and_task_api (end)