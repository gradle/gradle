/*
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gradle.api.tasks.wrapper;

import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.Incubating;
import org.gradle.api.UncheckedIOException;
import org.gradle.api.file.RegularFile;
import org.gradle.api.file.RegularFileProperty;
import org.gradle.api.internal.file.FileLookup;
import org.gradle.api.internal.file.FileOperations;
import org.gradle.api.internal.file.FileResolver;
import org.gradle.api.model.ObjectFactory;
import org.gradle.api.provider.Property;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.TaskAction;
import org.gradle.api.tasks.options.Option;
import org.gradle.api.tasks.options.OptionValues;
import org.gradle.api.tasks.wrapper.internal.DefaultWrapperVersionsResources;
import org.gradle.api.tasks.wrapper.internal.WrapperDefaults;
import org.gradle.api.tasks.wrapper.internal.WrapperGenerator;
import org.gradle.internal.instrumentation.api.annotations.ReplacesEagerProperty;
import org.gradle.internal.instrumentation.api.annotations.ToBeReplacedByLazyProperty;
import org.gradle.util.GradleVersion;
import org.gradle.util.internal.GUtil;
import org.gradle.util.internal.WrapperDistributionUrlConverter;
import org.gradle.work.DisableCachingByDefault;
import org.gradle.wrapper.Download;
import org.gradle.wrapper.Logger;
import org.gradle.wrapper.WrapperExecutor;

import javax.inject.Inject;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

/**
 * <p>Generates scripts (for *nix and windows) which allow you to build your project with Gradle, without having to
 * install Gradle.
 *
 * <p>When a user executes a wrapper script the first time, the script downloads and installs the appropriate Gradle
 * distribution and runs the build against this downloaded distribution. Any installed Gradle distribution is ignored
 * when using the wrapper scripts.
 *
 * <p>The scripts generated by this task are intended to be committed to your version control system. This task also
 * generates a small {@code gradle-wrapper.jar} bootstrap JAR file and properties file which should also be committed to
 * your VCS. The scripts delegates to this JAR.
 */
@DisableCachingByDefault(because = "Updating the wrapper is not worth caching")
public abstract class Wrapper extends DefaultTask {

    public static final String DEFAULT_DISTRIBUTION_PARENT_NAME = WrapperDefaults.DISTRIBUTION_PATH;
    private static final String DISTRIBUTION_URL_EXCEPTION_MESSAGE = "Test of distribution url %s failed. Please check the values set with --gradle-distribution-url and --gradle-version.";

    /**
     * Specifies the Gradle distribution type.
     */
    public enum DistributionType {
        /**
         * binary-only Gradle distribution without sources and documentation
         */
        BIN,
        /**
         * complete Gradle distribution with binaries, sources and documentation
         */
        ALL
    }

    /**
     * Specifies how the wrapper path should be interpreted.
     */
    public enum PathBase {
        PROJECT, GRADLE_USER_HOME
    }

    private final GradleVersionResolver gradleVersionResolver = new GradleVersionResolver();
    private final Property<Integer> networkTimeout = getProject().getObjects().property(Integer.class);
    private final boolean isOffline = getProject().getGradle().getStartParameter().isOffline();
    private final RegularFileProperty batchScript;
    private final RegularFileProperty propertiesFile;

    public Wrapper() {
        getValidateDistributionUrl().convention(WrapperDefaults.VALIDATE_DISTRIBUTION_URL);
        getScriptFile().convention(getProject().getObjects().fileProperty()).fileValue(getFileOperations().file(WrapperDefaults.SCRIPT_PATH));
        getJarFile().convention(getProject().getObjects().fileProperty()).fileValue(getFileOperations().file(WrapperDefaults.JAR_FILE_PATH));
        getDistributionPath().convention(DEFAULT_DISTRIBUTION_PARENT_NAME);
        getDistributionBase().convention(WrapperDefaults.DISTRIBUTION_BASE);
        getDistributionType().convention(WrapperDefaults.DISTRIBUTION_TYPE);
        getArchivePath().convention(WrapperDefaults.ARCHIVE_PATH);
        getArchiveBase().convention(WrapperDefaults.ARCHIVE_BASE);
        getGradleVersion().convention(GradleVersion.current().getVersion());
        getDistributionUrl().convention(getGradleVersion().zip(getDistributionType(), this::getDistributionUrl));
        this.batchScript = getObjectFactory().fileProperty().fileProvider(getScriptFile().getLocationOnly().map(file -> WrapperGenerator.getBatchScript(file.getAsFile())));
        this.propertiesFile = getObjectFactory().fileProperty().fileProvider(getJarFile().getLocationOnly().map(file -> WrapperGenerator.getPropertiesFile(file.getAsFile())));
    }

    @TaskAction
    void generate() {
        File jarFileDestination = getJarFile().get().getAsFile();
        File unixScript = getScriptFile().getAsFile().get();
        FileResolver resolver = getFileLookup().getFileResolver(unixScript.getParentFile());
        String jarFileRelativePath = resolver.resolveAsRelativePath(jarFileDestination);
        File propertiesFile = getPropertiesFile().get().getAsFile();
        Properties existingProperties = propertiesFile.exists() ? GUtil.loadProperties(propertiesFile) : null;
        // TODO: Remove storing version in GradleVersionResolver
        gradleVersionResolver.setGradleVersionString(getGradleVersion().get());

        checkProperties(existingProperties);
        String distributionUrl = getDistributionUrl().get();
        String defaultDistributionUrl = getDistributionUrl(GradleVersion.current().getVersion(), getDistributionType().get());
        if (!defaultDistributionUrl.equals(getDistributionUrl().get())) {
            // When custom version or distribution url is configured do a validation
            validateDistributionUrl(distributionUrl, propertiesFile.getParentFile());
        }

        WrapperGenerator.generate(
            getArchiveBase().get(),
            getArchivePath().get(),
            getDistributionBase().get(),
            getDistributionPath().get(),
            getDistributionSha256Sum(existingProperties),
            propertiesFile,
            jarFileDestination,
            jarFileRelativePath,
            unixScript,
            getBatchScript().get().getAsFile(),
            distributionUrl,
            getValidateDistributionUrl().get(),
            networkTimeout.getOrNull()
        );
    }

    private String getDistributionUrl(String version, DistributionType distributionType) {
        return WrapperGenerator.getDistributionUrl(gradleVersionResolver.resolveGradleVersion(version), distributionType);
    }

    private void checkProperties(Properties existingProperties) {
        String checksumProperty = existingProperties != null
            ? existingProperties.getProperty(WrapperExecutor.DISTRIBUTION_SHA_256_SUM, null)
            : null;

        if (!isCurrentVersion() &&
            getDistributionSha256Sum().getOrNull() == null &&
            checksumProperty != null) {
            throw new GradleException("gradle-wrapper.properties contains distributionSha256Sum property, but the wrapper configuration does not have one. Specify one in the wrapper task configuration or with the --gradle-distribution-sha256-sum task option");
        }
    }

    private void validateDistributionUrl(String url, File uriRoot) {
        if (getValidateDistributionUrl().get()) {
            URI uri = getDistributionUri(uriRoot, url);
            if (uri.getScheme().equals("file")) {
                if (!Files.exists(Paths.get(uri).toAbsolutePath())) {
                    throw new UncheckedIOException(String.format(DISTRIBUTION_URL_EXCEPTION_MESSAGE, url));
                }
            } else if (uri.getScheme().startsWith("http") && !isOffline) {
                try {
                    new Download(new Logger(true), "gradlew", Download.UNKNOWN_VERSION).sendHeadRequest(uri);
                } catch (Exception e) {
                    throw new UncheckedIOException(String.format(DISTRIBUTION_URL_EXCEPTION_MESSAGE, url), e);
                }
            }
        }
    }

    private static URI getDistributionUri(File uriRoot, String url) {
        try {
            return WrapperDistributionUrlConverter.convertDistributionUrl(url, uriRoot);
        } catch (URISyntaxException e) {
            throw new GradleException("Distribution URL String cannot be parsed: " + url, e);
        }
    }

    private String getDistributionSha256Sum(Properties existingProperties) {
        String distributionSha256Sum = getDistributionSha256Sum().getOrNull();
        if (distributionSha256Sum != null) {
            return distributionSha256Sum;
        } else if (isCurrentVersion() && existingProperties != null) {
            return existingProperties.getProperty(WrapperExecutor.DISTRIBUTION_SHA_256_SUM, null);
        } else {
            return null;
        }
    }

    private boolean isCurrentVersion() {
        return GradleVersion.current().equals(gradleVersionResolver.getGradleVersion());
    }

    /**
     * Returns the file to write the wrapper script to.
     */
    @OutputFile
    @ReplacesEagerProperty
    public abstract RegularFileProperty getScriptFile();

    /**
     * Returns the file to write the wrapper batch script to.
     */
    @OutputFile
    @ReplacesEagerProperty
    public Provider<RegularFile> getBatchScript() {
        // We return a RegularFileProperty, since Provider<RegularFile>
        // doesn't track task dependencies, see: https://github.com/gradle/gradle/issues/29335
        return batchScript;
    }

    /**
     * Returns the file to write the wrapper jar file to.
     */
    @OutputFile
    @ReplacesEagerProperty
    public abstract RegularFileProperty getJarFile();

    /**
     * Returns the file to write the wrapper properties to.
     */
    @OutputFile
    @ReplacesEagerProperty
    public Provider<RegularFile> getPropertiesFile() {
        // We return a RegularFileProperty, since Provider<RegularFile>
        // doesn't track task dependencies, see: https://github.com/gradle/gradle/issues/29335
        return propertiesFile;
    }

    /**
     * Returns the path where the gradle distributions needed by the wrapper are unzipped. The path is relative to the
     * distribution base directory
     */
    @Input
    @ReplacesEagerProperty
    public abstract Property<String> getDistributionPath();

    /**
     * Set Wrapper versions resources.
     *
     * @since 8.1
     */
    @Incubating
    public void setWrapperVersionsResources(WrapperVersionsResources wrapperVersionsResources) {
        DefaultWrapperVersionsResources defaultWrapperVersionsResources = (DefaultWrapperVersionsResources) wrapperVersionsResources;
        gradleVersionResolver.setTextResources(defaultWrapperVersionsResources.getLatest(),
            defaultWrapperVersionsResources.getReleaseCandidate(),
            defaultWrapperVersionsResources.getNightly(),
            defaultWrapperVersionsResources.getReleaseNightly());
    }

    /**
     * The version of the gradle distribution required by the wrapper.
     * This is usually the same version of Gradle you use for building your project.
     * The following labels are allowed to specify a version: {@code latest}, {@code release-candidate}, {@code nightly}, and {@code release-nightly}
     *
     * <p>The resulting distribution url is validated before it is written to the gradle-wrapper.properties file.
     */
    @Input
    @ReplacesEagerProperty
    @Option(option = "gradle-version", description = "The version of the Gradle distribution required by the wrapper. " +
        "The following labels are allowed: latest, release-candidate, nightly, and release-nightly.")
    public abstract Property<String> getGradleVersion();

    /**
     * Returns the type of the Gradle distribution to be used by the wrapper. By default, this is {@link DistributionType#BIN},
     * which is the binary-only Gradle distribution without documentation.
     */
    @Input
    @ReplacesEagerProperty
    @Option(option = "distribution-type", description = "The type of the Gradle distribution to be used by the wrapper.")
    public abstract Property<DistributionType> getDistributionType();

    /**
     * The list of available gradle distribution types.
     */
    @OptionValues("distribution-type")
    @ToBeReplacedByLazyProperty(comment = "Not supported yet", issue = "https://github.com/gradle/gradle/issues/29341")
    public List<DistributionType> getAvailableDistributionTypes() {
        return Arrays.asList(DistributionType.values());
    }

    /**
     * The URL to download the gradle distribution from.
     *
     * <p>If not set, the download URL is the default for the specified {@link #getGradleVersion()}.
     *
     * <p>If {@link #getGradleVersion()} is not set, will return null.
     *
     * <p>The wrapper downloads a certain distribution only once and caches it. If your distribution base is the
     * project, you might submit the distribution to your version control system. That way no download is necessary at
     * all. This might be in particular interesting, if you provide a custom gradle snapshot to the wrapper, because you
     * don't need to provide a download server then.
     *
     * <p>The distribution url is validated before it is written to the gradle-wrapper.properties file.
     */
    @Input
    @ReplacesEagerProperty
    @Option(option = "gradle-distribution-url", description = "The URL to download the Gradle distribution from.")
    public abstract Property<String> getDistributionUrl();

    /**
     * The SHA-256 hash sum of the gradle distribution.
     *
     * <p>If not set, the hash sum of the gradle distribution is not verified.
     *
     * <p>The wrapper allows for verification of the downloaded Gradle distribution via SHA-256 hash sum comparison.
     * This increases security against targeted attacks by preventing a man-in-the-middle attacker from tampering with
     * the downloaded Gradle distribution.
     *
     * @since 4.5
     */
    @Input
    @Optional
    @ReplacesEagerProperty
    @Option(option = "gradle-distribution-sha256-sum", description = "The SHA-256 hash sum of the gradle distribution.")
    public abstract Property<String> getDistributionSha256Sum();

    /**
     * The distribution base specifies whether the unpacked wrapper distribution should be stored in the project or in
     * the gradle user home dir.
     */
    @Input
    @ReplacesEagerProperty
    public abstract Property<PathBase> getDistributionBase();

    /**
     * Returns the path where the gradle distributions archive should be saved (i.e. the parent dir). The path is
     * relative to the archive base directory.
     */
    @Input
    @ReplacesEagerProperty
    public abstract Property<String> getArchivePath();

    /**
     * The archive base specifies whether the unpacked wrapper distribution should be stored in the project or in the
     * gradle user home dir.
     */
    @Input
    @ReplacesEagerProperty
    public abstract Property<PathBase> getArchiveBase();

    /**
     * The network timeout specifies how many ms to wait for when the wrapper is performing network operations, such
     * as downloading the wrapper jar.
     *
     * @since 7.6
     */
    @Input
    @Incubating
    @Optional
    @Option(option = "network-timeout", description = "Timeout in ms to use when the wrapper is performing network operations.")
    public Property<Integer> getNetworkTimeout() {
        return networkTimeout;
    }

    /**
     * Indicates if this task will validate the distribution url that has been configured.
     *
     * @return whether this task will validate the distribution url
     * @since 8.2
     */
    @Incubating
    @Input
    @Option(option = "validate-url", description = "Sets task to validate the configured distribution url.")
    public abstract Property<Boolean> getValidateDistributionUrl();

    @Inject
    protected FileLookup getFileLookup() {
        throw new UnsupportedOperationException();
    }

    @Inject
    protected abstract FileOperations getFileOperations();

    @Inject
    protected abstract ObjectFactory getObjectFactory();
}
