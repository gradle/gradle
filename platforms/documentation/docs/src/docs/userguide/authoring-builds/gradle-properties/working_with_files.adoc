// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[working_with_files]]
= Working With Files

File operations are fundamental to nearly every Gradle build.
They involve handling source files, managing file dependencies, and generating reports.
Gradle provides a robust API that simplifies these operations, enabling developers to perform necessary file tasks easily.

[[sec:hard_coded_file_paths]]
== Hardcoded paths and laziness

It is best practice to *avoid* hardcoded paths in build scripts.

In addition to avoiding hardcoded paths, Gradle encourages laziness in its build scripts.
This means that tasks and operations should be deferred until they are actually needed rather than executed eagerly.

Many examples in this chapter use hard-coded paths as string literals.
This makes them easy to understand, but it is not good practice.
The problem is that paths often change, and the more places you need to change them, the more likely you will miss one and break the build.

Where possible, you should use tasks, task properties, and <<properties_providers.adoc#understanding_properties,project properties>> — in that order of preference — to configure file paths.

For example, if you create a task that packages the compiled classes of a Java application,  you should use an implementation similar to this:

====
include::sample[dir="snippets/files/sampleJavaProject/kotlin",files="build.gradle.kts[tags=link-task-properties]"]
include::sample[dir="snippets/files/sampleJavaProject/groovy",files="build.gradle[tags=link-task-properties]"]
====

The `compileJava` task is the source of the files to package, and the project property `archivesDirPath` stores the location of the archives, as we are likely to use it elsewhere in the build.

Using a task directly as an argument like this relies on it having <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>>, so it won't always be possible.
This example could be further improved by relying on the Java plugin's convention for `destinationDirectory` rather than overriding it, but it does demonstrate the use of project properties.

[[sec:locating_files]]
== Locating files

To perform some action on a file, you need to know where it is, and that's the information provided by file paths.
Gradle builds on the standard Java `{javaApi}/java/io/File.html[File]` class, which represents the location of a single file and provides APIs for dealing with collections of paths.

=== Using `ProjectLayout`

The link:{groovyDslPath}/org.gradle.api.file.ProjectLayout.html[`ProjectLayout`] class is used to access various directories and files within a project.
It provides methods to retrieve paths to the project directory, build directory, settings file, and other important locations within the project's file structure.
This class is particularly useful when you need to work with files in a build script or plugin in different project paths:

====
include::sample[dir="snippets/files/sampleJavaProject/kotlin",files="build.gradle.kts[tags=inner-link-task-properties]"]
include::sample[dir="snippets/files/sampleJavaProject/groovy",files="build.gradle[tags=inner-link-task-properties]"]
====

You can learn more about the `ProjectLayout` class in <<service_injection.adoc#sec:projectlayout,Services>>.

[[sec:single_file_paths]]
=== Using `Project.file()`

Gradle provides the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] method for specifying the location of a single file or directory.

Relative paths are resolved relative to the project directory, while absolute paths remain unchanged.

[CAUTION]
====
Never use `new File(relative path)` unless passed to `file()` or `files()` or `from()` or other methods defined in terms of `file()` or `files()`.
Otherwise, this creates a path relative to the current working directory (CWD).
Gradle can make no guarantees about the location of the CWD, which means builds that rely on it may break at any time.
====

Here are some examples of using the `file()` method with different types of arguments:

====
include::sample[dir="snippets/files/file/kotlin",files="build.gradle.kts[tags=simple-params]"]
include::sample[dir="snippets/files/file/groovy",files="build.gradle[tags=simple-params]"]
====

As you can see, you can pass strings, `File` instances and `{javaApi}/java/nio/file/Path.html[Path]` instances to the `file()` method, all of which result in an absolute `File` object.

In the case of multi-project builds, the `file()` method will always turn relative paths into paths relative to the current project directory, which may be a child project.

=== Using `Project.getRootDir()`

Suppose you want to use a path relative to the _root project_ directory. In that case, you need to use the special link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:rootDir[Project.getRootDir()] property to construct an absolute path, like so:

====
include::sample[dir="snippets/files/misc/kotlin/project2",files="build.gradle.kts[tags=using-root-dir-property]"]
include::sample[dir="snippets/files/misc/groovy/project2",files="build.gradle[tags=using-root-dir-property]"]
====

Let's say you're working on a multi-project build in the directory: `dev/projects/AcmeHealth`. +
The build script above is at: `AcmeHealth/subprojects/AcmePatientRecordLib/build.gradle`. +
The file path will resolve to the absolute of: `dev/projects/AcmeHealth/shared/config.xml`.

[source, text]
----
dev
├── projects
│   ├── AcmeHealth
│   │   ├── subprojects
│   │   │   ├── AcmePatientRecordLib
│   │   │   │   └── build.gradle
│   │   │   └── ...
│   │   ├── shared
│   │   │   └── config.xml
│   │   └── ...
│   └── ...
└── settings.gradle
----

Note that `Project` also provides link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:rootProject[Project.getRootProject()] for multi-project builds which, in the example, would resolve to: `dev/projects/AcmeHealth/subprojects/AcmePatientRecordLib`.

[[sec:file_collections]]
=== Using `FileCollection`

A _file collection_ is simply a set of file paths represented by the link:{javadocPath}/org/gradle/api/file/FileCollection.html[FileCollection] interface.

The set of paths can be _any_ file path.
The file paths don't have to be related in any way, so they don't have to be in the same directory or have a shared parent directory.

The recommended way to specify a collection of files is to use the link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object++...++-[ProjectLayout.files(java.lang.Object++...++)] method, which returns a `FileCollection` instance.
This flexible method allows you to pass multiple strings, `File` instances, collections of strings, collections of ``File``s, and more.
You can also pass in tasks as arguments if they have <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>>.

CAUTION: `files()` properly handles relative paths and `File(relative path)` instances, resolving them relative to the project directory.

As with the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] method covered in the <<#sec:single_file_paths,previous section>>, all relative paths are evaluated relative to the current project directory.
The following example demonstrates some of the variety of argument types you can use — strings, `File` instances, lists, or  `{javaApi}/java/nio/file/Path.html[Path]s`:

====
include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=simple-params]"]
include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=simple-params]"]
====

File collections have important attributes in Gradle.
They can be:

* created lazily
* iterated over
* filtered
* combined

_Lazy creation_ of a file collection is useful when evaluating the files that make up a collection when a build runs.
In the following example, we query the file system to find out what files exist in a particular directory and then make those into a file collection:

====
include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=closure]"]
include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=closure]"]
====

----
$ gradle -q list
include::{snippetsPath}/files/fileCollections/tests/fileCollectionsWithClosure.out[]
----

The key to lazy creation is passing a closure (in Groovy) or a `Provider` (in Kotlin) to the `files()` method.
Your closure or provider must return a value of a type accepted by `files()`, such as `List<File>`, `String`, or `FileCollection`.

_Iterating over a file collection_ can be done through the `each()` method (in Groovy) or `forEach` method (in Kotlin) on the collection or using the collection in a `for` loop.
In both approaches, the file collection is treated as a set of `File` instances, i.e., your iteration variable will be of type `File`.

The following example demonstrates such iteration.
It also demonstrates how you can convert file collections to other types using the `as` operator (or supported properties):

====
include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=usage]"]
include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=usage]"]
====

You can also see at the end of the example _how to combine file collections_ using the `+` and `-` operators to merge and subtract them.
An important feature of the resulting file collections is that they are _live_.
In other words, when you combine file collections this way, the result always reflects what's currently in the source file collections, even if they change during the build.

For example, imagine `collection` in the above example gains an extra file or two after `union` is created.
As long as you use `union` after those files are added to `collection`, `union` will also contain those additional files.
The same goes for the `different` file collection.

Live collections are also important when it comes to _filtering_.
Suppose you want to use a subset of a file collection.
In that case, you can take advantage of the link:{javadocPath}/org/gradle/api/file/FileCollection.html#filter-org.gradle.api.specs.Spec-[FileCollection.filter(org.gradle.api.specs.Spec)] method to determine which files to "keep".
In the following example, we create a new collection that consists of only the files that end with `.txt` in the source collection:

====
include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=filtering-file-collections]"]
include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=filtering-file-collections]"]
====

----
$ gradle -q filterTextFiles
include::{snippetsPath}/files/fileCollections/tests/fileCollectionsFiltering.out[]
----

If `collection` changes at any time, either by adding or removing files from itself, then `textFiles` will immediately reflect the change because it is also a live collection.
Note that the closure you pass to `filter()` takes a `File` as an argument and should return a boolean.

[[sec:specifying_multiple_files]]
=== Understanding implicit conversion to file collections

Many objects in Gradle have properties which accept a set of input files.
For example, the link:{groovyDslPath}/org.gradle.api.tasks.compile.JavaCompile.html[JavaCompile] task has a `source` property that defines the source files to compile.
You can set the value of this property using any of the types supported by the <<#sec:file_collections,files()>> method, as mentioned in the API docs.
This means you can, for example, set the property to a `File`, `String`, collection, `FileCollection` or even a closure or `Provider`.

*This is a feature of specific tasks*!
That means implicit conversion will not happen for just any task that has a `FileCollection` or `FileTree` property.
If you want to know whether implicit conversion happens in a particular situation, you will need to read the relevant documentation, such as the corresponding task's API docs.
Alternatively, you can remove all doubt by explicitly using link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object++...++-[ProjectLayout.files(java.lang.Object++...++)] in your build.

Here are some examples of the different types of arguments that the `source` property can take:

====
include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=set-input-files]"]
include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=set-input-files]"]
====

One other thing to note is that properties like `source` have corresponding methods in core Gradle tasks.
Those methods follow the convention of _appending_ to collections of values rather than replacing them.
Again, this method accepts any of the types supported by the <<#sec:file_collections,files()>> method, as shown here:

====
include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=add-input-files]"]
include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=add-input-files]"]
====

As this is a common convention, we recommend that you follow it in your own custom tasks.
Specifically, if you plan to add a method to configure a collection-based property, make sure the method appends rather than replaces values.

[[sec:file_trees]]
=== Using `FileTree`

A _file tree_ is a file collection that retains the directory structure of the files it contains and has the type link:{javadocPath}/org/gradle/api/file/FileTree.html[FileTree].
This means all the paths in a file tree must have a shared parent directory.
The following diagram highlights the distinction between file trees and file collections in the typical case of copying files:

image::file-collection-vs-file-tree.png[]

NOTE: Although `FileTree` extends `FileCollection` (an is-a relationship), their behaviors differ.
In other words, you can use a file tree wherever a file collection is required, but remember that a file collection is a flat list/set of files, while a file tree is a file and directory hierarchy.
To convert a file tree to a flat collection, use the link:{javadocPath}/org/gradle/api/file/FileTree.html#getFiles--[FileTree.getFiles()] property.

The simplest way to create a file tree is to pass a file or directory path to the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)[Project.fileTree(java.lang.Object)] method.
This will create a tree of all the files and directories in that base directory (but not the base directory itself).
The following example demonstrates how to use this method and how to filter the files and directories using Ant-style patterns:

====
include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=define]"]
include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=define]"]
====

You can see more examples of supported patterns in the API docs for link:{javadocPath}/org/gradle/api/tasks/util/PatternFilterable.html[PatternFilterable].

By default, `fileTree()` returns a `FileTree` instance that applies some default exclude patterns for convenience — the same defaults as Ant.
For the complete default exclude list, see http://ant.apache.org/manual/dirtasks.html#defaultexcludes[the Ant manual].

[[sec:change_default_excludes]]
If those default excludes prove problematic, you can work around the issue by changing the default excludes in the settings script:

====
include::sample[dir="snippets/files/copy/kotlin",files="settings.gradle.kts[tags=change-default-exclusions]"]
include::sample[dir="snippets/files/copy/groovy",files="settings.gradle[tags=change-default-exclusions]"]
====

IMPORTANT: Gradle does not support changing default excludes during the execution phase.

You can do many of the same things with file trees that you can with file collections:

* iterate over them (depth first)
* filter them (using link:{javadocPath}/org/gradle/api/file/FileTree.html#matching-org.gradle.api.Action-[FileTree.matching(org.gradle.api.Action)] and Ant-style patterns)
* merge them

You can also traverse file trees using the link:{javadocPath}/org/gradle/api/file/FileTree.html#visit-org.gradle.api.Action-[FileTree.visit(org.gradle.api.Action)] method.
All of these techniques are demonstrated in the following example:

====
include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=use]"]
include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=use]"]
====

== Copying files

Copying files in Gradle primarily uses `CopySpec`, a mechanism that makes it easy to manage resources such as source code, configuration files, and other assets in your project build process.

[[sec:using_the_copyspec_class]]
=== Understanding `CopySpec`
`CopySpec` is a copy specification that allows you to define what files to copy, where to copy them from, and where to copy them.
It provides a flexible and expressive way to specify complex file copying operations, including filtering files based on patterns, renaming files, and including/excluding files based on various criteria.

`CopySpec` instances are used in the `Copy` task to specify the files and directories to be copied.

`CopySpec` has two important attributes:

1. It is independent of tasks, allowing you to _share copy specs within a build_.
2. It is hierarchical, providing _fine-grained control_ within the overall copy specification.

[[sub:sharing_copy_specs]]
==== 1. Sharing copy specs
Consider a build with several tasks that copy a project's static website resources or add them to an archive.
One task might copy the resources to a folder for a local HTTP server, and another might package them into a distribution.
You could manually specify the file locations and appropriate inclusions each time they are needed, but human error is more likely to creep in, resulting in inconsistencies between tasks.

One solution is the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:copySpec(org.gradle.api.Action)[Project.copySpec(org.gradle.api.Action)] method.
This allows you to create a copy spec outside a task, which can then be attached to an appropriate task using the link:{javadocPath}/org/gradle/api/file/CopySpec.html#with-org.gradle.api.file.CopySpec++...++-[CopySpec.with(org.gradle.api.file.CopySpec...)] method.
The following example demonstrates how this is done:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=standalone-copyspec]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=standalone-copyspec]"]
====

Both the `copyAssets` and `distApp` tasks will process the static resources under `src/main/webapp`, as specified by `webAssetsSpec`.

[NOTE]
====
The configuration defined by `webAssetsSpec` will _not_ apply to the app classes included by the `distApp` task.
That's because `from appClasses` is its own child specification independent of `with webAssetsSpec`.

This can be confusing, so it's probably best to treat `with()` as an extra `from()` specification in the task.
Hence, it doesn't make sense to define a standalone copy spec without at least one `from()` defined.
====

Suppose you encounter a scenario in which you want to apply the same copy configuration to _different_ sets of files.
In that case, you can share the configuration block directly without using `copySpec()`.
Here's an example that has two independent tasks that happen to want to process image files only:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=shared-copy-patterns]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=shared-copy-patterns]"]
====

In this case, we assign the copy configuration to its own variable and apply it to whatever `from()` specification we want.
This doesn't just work for inclusions but also exclusions, file renaming, and file content filtering.

[[sub:using_child_copy_specifications]]
==== 2. Using child specifications
If you only use a single copy spec, the file filtering and renaming will apply to _all_ files copied.
Sometimes, this is what you want, but not always.
Consider the following example that copies files into a directory structure that a Java Servlet container can use to deliver a website:

image::exploded-war-child-copy-spec-example.png[]

This is not a straightforward copy as the `WEB-INF` directory and its subdirectories don't exist within the project, so they must be created during the copy.
In addition, we only want HTML and image files going directly into the root folder — `build/explodedWar` — and only JavaScript files going into the `js` directory.
We need separate filter patterns for those two sets of files.

The solution is to use _child specifications_, which can be applied to both `from()` and `into()` declarations.
The following task definition does the necessary work:

====
include::sample[dir="snippets/files/sampleJavaProject/kotlin",files="build.gradle.kts[tags=nested-specs]"]
include::sample[dir="snippets/files/sampleJavaProject/groovy",files="build.gradle[tags=nested-specs]"]
====

Notice how the `src/dist` configuration has a nested inclusion specification; it is the child copy spec.
You can, of course, add content filtering and renaming here as required.
A child copy spec is still a copy spec.

The above example also demonstrates how you can copy files into a subdirectory of the destination either by using a child `into()` on a `from()` or a child `from()` on an `into()`.
Both approaches are acceptable, but you should create and follow a convention to ensure consistency across your build files.

[NOTE]
====
Don't get your `into()` specifications mixed up.
For a normal copy, one to the filesystem rather than an archive, there should always be _one_ "root" `into()` that specifies the overall destination directory of the copy.
Any other `into()` should have a child spec attached, and its path will be relative to the root `into()`.
====

One final thing to be aware of is that a child copy spec inherits its destination path, include patterns, exclude patterns, copy actions, name mappings, and filters from its parent.
So, be careful where you place your configuration.

[[sec:sync_task]]
=== Using the `Sync` task

The link:{groovyDslPath}/org.gradle.api.tasks.Sync.html[Sync] task, which extends the `Copy` task, copies the source files into the destination directory and then removes any files from the destination directory which it did not copy.
It synchronizes the contents of a directory with its source.

This can be useful for doing things such as installing your application, creating an exploded copy of your archives, or maintaining a copy of the project's dependencies.

Here is an example that maintains a copy of the project's runtime dependencies in the `build/libs` directory:

====
include::sample[dir="snippets/files/sync/kotlin",files="build.gradle.kts[tags=copy-dependencies]"]
include::sample[dir="snippets/files/sync/groovy",files="build.gradle[tags=copy-dependencies]"]
====

You can also perform the same function in your own tasks with the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:sync(org.gradle.api.Action)[Project.sync(org.gradle.api.Action)] method.

[[sec:copying_single_file_example]]
=== Using the `Copy` task

You can copy a file by creating an instance of Gradle's builtin link:{groovyDslPath}/org.gradle.api.tasks.Copy.html[Copy] task and configuring it with the location of the file and where you want to put it.

This example mimics copying a generated report into a directory that will be packed into an archive, such as a ZIP or TAR:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-single-file-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-single-file-example]"]
====

The file and directory paths are then used to specify what file to copy using link:{groovyDslPath}/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:from(java.lang.Object++[]++)[Copy.from(java.lang.Object...)] and which directory to copy it to using link:{groovyDslPath}/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:into(java.lang.Object)[Copy.into(java.lang.Object)].

Although hard-coded paths make for simple examples, they make the build brittle.
Using a reliable, single source of truth, such as a task or shared project property, is better.
In the following modified example, we use a report task defined elsewhere that has the report's location stored in its `outputFile` property:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-single-file-example-with-task-properties]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-single-file-example-with-task-properties]"]
====

We have also assumed that the reports will be archived by `archiveReportsTask`, which provides us with the directory that will be archived and hence where we want to put the copies of the reports.

[[sec:copying_multiple_files_example]]
=== Copying multiple files

You can extend the previous examples to multiple files very easily by providing multiple arguments to `from()`:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-example]"]
====

Two files are now copied into the archive directory.

You can also use multiple `from()` statements to do the same thing, as shown in the first example of the section <<#sec:copying_files, File copying in depth>>.

But what if you want to copy all the PDFs in a directory without specifying each one?
To do this, attach inclusion and/or exclusion patterns to the copy specification.
Here, we use a string pattern to include PDFs only:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-with-flat-filter-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-with-flat-filter-example]"]
====

One thing to note, as demonstrated in the following diagram, is that only the PDFs that reside directly in the `reports` directory are copied:

image::copy-with-flat-filter-example.png[]

You can include files in subdirectories by using an Ant-style glob pattern (`\**/*`), as done in this updated example:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-with-deep-filter-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-with-deep-filter-example]"]
====

This task has the following effect:

image::copy-with-deep-filter-example.png[]

Remember that a deep filter like this has the side effect of copying the directory structure below `reports` and the files.
If you want to copy the files without the directory structure, you must use an explicit `fileTree(_dir_) { _includes_ }.files` expression.

[[sec:copying_directories_example]]
=== Copying directory hierarchies

You may need to copy files as well as the directory structure in which they reside.
This is the default behavior when you specify a directory as the `from()` argument, as demonstrated by the following example that copies everything in the `reports` directory, including all its subdirectories, to the destination:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-directory-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-directory-example]"]
====

The key aspect that users need help with is controlling how much of the directory structure goes to the destination.
In the above example, do you get a `toArchive/reports` directory, or does everything in `reports` go straight into `toArchive`?
The answer is the latter. If a directory is part of the `from()` path, then it _won't_ appear in the destination.

So how do you ensure that `reports` itself is copied across, but not any other directory in `${layout.buildDirectory}`?
The answer is to add it as an include pattern:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-directory-including-itself-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-directory-including-itself-example]"]
====

You'll get the same behavior as before except with one extra directory level in the destination, i.e., `toArchive/reports`.

One thing to note is how the `include()` directive applies only to the `from()`, whereas the directive in the previous section applied to the whole task.
These different <<sub:using_child_copy_specifications,levels of granularity>> in the copy specification allow you to handle most requirements that you will come across easily.

[[sec:copying_files]]
=== Understanding file copying

The basic process of copying files in Gradle is a simple one:

* Define a task of type link:{groovyDslPath}/org.gradle.api.tasks.Copy.html[Copy]
* Specify which files (and potentially directories) to copy
* Specify a destination for the copied files

But this apparent simplicity hides a rich API that allows fine-grained control of which files are copied, where they go, and what happens to them as they are copied — renaming of the files and token substitution of file content are both possibilities, for example.

Let's start with the last two items on the list, which involve <<sec:using_the_copyspec_class,`CopySpec`>>.
The link:{javadocPath}/org/gradle/api/file/CopySpec.html[CopySpec] interface, which the `Copy` task implements, offers:

* A link:{javadocPath}/org/gradle/api/file/CopySpec.html#from-java.lang.Object++...++-[CopySpec.from(java.lang.Object...)] method to define what to copy
* An link:{javadocPath}/org/gradle/api/file/CopySpec.html#into-java.lang.Object-[CopySpec.into(java.lang.Object)] method to define the destination

`CopySpec` has several additional methods that allow you to control the copying process, but these two are the only required ones.
`into()` is straightforward, requiring a directory path as its argument in any form supported by the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] method.
The `from()` configuration is far more flexible.

Not only does `from()` accept multiple arguments, it also allows several different types of argument.
For example, some of the most common types are:

* A `String` — treated as a file path or, if it starts with "file://", a file URI
* A `File` — used as a file path
* A `FileCollection` or `FileTree` — all files in the collection are included in the copy
* A task — the files or directories that form a task's <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>> are included

In fact, `from()` accepts all the same arguments as link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[Project.files(java.lang.Object...)] so see that method for a more detailed list of acceptable types.

Something else to consider is what type of thing a file path refers to:

* A file — the file is copied as is
* A directory — this is effectively treated as a file tree: everything in it, including subdirectories, is copied. However, the directory itself is not included in the copy.
* A non-existent file — the path is ignored

Here is an example that uses multiple `from()` specifications, each with a different argument type.
You will probably also notice that `into()` is configured lazily using a closure (in Groovy) or a Provider (in Kotlin) — a technique that also works with `from()`:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-task-2]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-task-2]"]
====

Note that the lazy configuration of `into()` is different from a <<#sub:using_child_copy_specifications,child specification>>, even though the syntax is similar.
Keep an eye on the number of arguments to distinguish between them.

[[sec:project_copy_method]]
=== Copying files in your own tasks

WARNING: Using the `Project.copy` method at execution time, as described here, is not compatible with the <<configuration_cache.adoc#config_cache:requirements:use_project_during_execution,configuration cache>>.
A possible solution is to implement the task as a proper class and use link:{javadocPath}/org/gradle/api/file/FileSystemOperations.html#copy-org.gradle.api.Action-[FileSystemOperations.copy] method instead, as described in the <<configuration_cache.adoc#config_cache:troubleshooting,configuration cache chapter>>.

Occasionally, you want to copy files or directories as _part_ of a task.
For example, a custom archiving task based on an unsupported archive format might want to copy files to a temporary directory before they are archived.
You still want to take advantage of Gradle's copy API without introducing an extra `Copy` task.

The solution is to use the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)[Project.copy(org.gradle.api.Action)] method.
Configuring it with a copy spec works like the `Copy` task.
Here's a trivial example:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-method]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-method]"]
====

The above example demonstrates the basic syntax and also highlights two major limitations of using the `copy()` method:

1. The `copy()` method is not <<incremental_build.adoc#incremental_build,incremental>>.
The example's `copyMethod` task will _always_ execute because it has no information about what files make up the task's inputs.
You have to define the task inputs and outputs manually.

2. Using a task as a copy source, i.e., as an argument to `from()`, won't create an automatic task dependency between your task and that copy source.
As such, if you use the `copy()` method as part of a task action, you must explicitly declare all inputs and outputs to get the correct behavior.

The following example shows how to work around these limitations using the <<incremental_build.adoc#sec:task_input_output_runtime_api,dynamic API for task inputs and outputs>>:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-method-with-dependency]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-method-with-dependency]"]
====

These limitations make it preferable to use the `Copy` task wherever possible because of its built-in support for incremental building and task dependency inference.
That is why the `copy()` method is intended for use by <<custom_tasks.adoc#custom_tasks,custom tasks>> that need to copy files as part of their function.
Custom tasks that use the `copy()` method should declare the necessary inputs and outputs relevant to the copy action.

== Renaming files

Renaming files in Gradle can be done using the `CopySpec` API, which provides methods for renaming files as they are copied.

[[sec:renaming_files_example]]
=== Using `Copy.rename()`

If the files used and generated by your builds sometimes don't have names that suit, you can rename those files as you copy them.
Gradle allows you to do this as part of a copy specification using the `rename()` configuration.

The following example removes the "-staging" marker from the names of any files that have it:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=rename-on-copy-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=rename-on-copy-example]"]
====

As in the above example, you can use regular expressions for this or closures that use more complex logic to determine the target filename.
For example, the following task truncates filenames:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=truncate-names-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=truncate-names-example]"]
====

As with filtering, you can also rename a subset of files by configuring it as part of a child specification on a `from()`.

[[sec:renaming_files]]
=== Using `Copyspec.rename{}`

The <<#sec:renaming_files_example,example of how to rename files on copy>> gives you most of the information you need to perform this operation.
It demonstrates the two options for renaming:

1. Using a regular expression
2. Using a closure

Regular expressions are a flexible approach to renaming, particularly as Gradle supports regex groups that allow you to remove and replace parts of the source filename.
The following example shows how you can remove the string "-staging" from any filename that contains it using a simple regular expression:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=rename-files]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=rename-files]"]
====

You can use any regular expression supported by the Java `{javaApi}/java/util/regex/Pattern.html[Pattern]` class and the substitution string.
The second argument of `rename()` works on the same principles as the `{javaApi}/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)[Matcher.appendReplacement()]` method.

.Regular expressions in Groovy build scripts
--
There are two common issues people come across when using regular expressions in this context:

1. If you use a slashy string (those delimited by '/') for the first argument, you _must_ include the parentheses for `rename()` as shown in the above example.
2. It's safest to use single quotes for the second argument, otherwise you need to escape the '$' in group substitutions, i.e. `"\$1\$2"`.

The first is a minor inconvenience, but slashy strings have the advantage that you don't have to escape backslash ('\') characters in the regular expression.
The second issue stems from Groovy's support for embedded expressions using `${ }` syntax in double-quoted and slashy strings.
--

The closure syntax for `rename()` is straightforward and can be used for any requirements that simple regular expressions can't handle.
You're given a file's name, and you return a new name for that file or `null` if you don't want to change the name.
Be aware that the closure will be executed for every file copied, so try to avoid expensive operations where possible.

[[filtering_files]]
== Filtering files

Filtering files in Gradle involves selectively including or excluding files based on certain criteria.

=== Using `CopySpec.include()` and `CopySpec.exclude()`

You can apply filtering in any copy specification through the link:{javadocPath}/org/gradle/api/file/CopySpec.html#include-java.lang.String++...++-[CopySpec.include(java.lang.String...)] and link:{javadocPath}/org/gradle/api/file/CopySpec.html#exclude-java.lang.String++...++-[CopySpec.exclude(java.lang.String...)] methods.

These methods are typically used with Ant-style include or exclude patterns, as described in link:{javadocPath}/org/gradle/api/tasks/util/PatternFilterable.html[PatternFilterable].

You can also perform more complex logic by using a closure that takes a link:{javadocPath}/org/gradle/api/file/FileTreeElement.html[FileTreeElement] and returns `true` if the file should be included or `false` otherwise.
The following example demonstrates both forms, ensuring that only `.html` and `.jsp` files are copied, except for those `.html` files with the word "DRAFT" in their content:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-task-with-patterns]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-task-with-patterns]"]
====

A question you may ask yourself at this point is what happens when inclusion and exclusion patterns overlap? Which pattern wins? Here are the basic rules:

* If there are no explicit inclusions or exclusions, everything is included
* If at least one inclusion is specified, only files and directories matching the patterns are included
* Any exclusion pattern overrides any inclusions, so if a file or directory matches at least one exclusion pattern, it won't be included, regardless of the inclusion patterns

Bear these rules in mind when creating combined inclusion and exclusion specifications so that you end up with the exact behavior you want.

Note that the inclusions and exclusions in the above example will apply to _all_ `from()` configurations.
If you want to apply filtering to a subset of the copied files, you'll need to use <<sub:using_child_copy_specifications,child specifications>>.

[[sec:filtering_files]]
== Filtering file content

Filtering file content in Gradle involves replacing placeholders or tokens in files with dynamic values.

=== Using `CopySpec.filter()`

Transforming the content of files while they are being copied involves basic templating that uses token substitution, removal of lines of text, or even more complex filtering using a full-blown template engine.

The following example demonstrates several forms of filtering, including token substitution using the link:{javadocPath}/org/gradle/api/file/CopySpec.html#expand-java.util.Map-[CopySpec.expand(java.util.Map)] method and another using link:{javadocPath}/org/gradle/api/file/CopySpec.html#filter-java.lang.Class-[CopySpec.filter(java.lang.Class)] with an https://ant.apache.org/manual/Types/filterchain.html[Ant filter]:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=filter-files]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=filter-files]"]
====

The `filter()` method has two variants, which behave differently:

* one takes a `{javaApi}/java/io/FilterReader.html[FilterReader]` and is designed to work with Ant filters, such as `ReplaceTokens`
* one takes a closure or link:{javadocPath}/org/gradle/api/Transformer.html[Transformer] that defines the transformation for each line of the source file

Note that both variants assume the source files are text-based.
When you use the `ReplaceTokens` class with `filter()`, you create a template engine that replaces tokens of the form `@tokenName@` (the Ant-style token) with values you define.

=== Using `CopySpec.expand()`

The `expand()` method treats the source files as https://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html[Groovy templates], which evaluates and expands expressions of the form `${expression}.`

You can pass in property names and values that are then expanded in the source files. `expand()` allows for more than basic token substitution as the embedded expressions are full-blown Groovy expressions.

NOTE: Specifying the character set when reading and writing the file is good practice.
Otherwise, the transformations won't work properly for non-ASCII text.
You configure the character set with the link:{javadocPath}/org/gradle/api/file/CopySpec.html#setFilteringCharset-java.lang.String-[CopySpec.setFilteringCharset(String)] property.
If it's not specified, the JVM default character set is used, which will likely differ from the one you want.

[[sec:setting_file_permissions]]
== Setting file permissions

Setting file permissions in Gradle involves specifying the permissions for files or directories created or modified during the build process.

=== Using `CopySpec.filePermissions{}`

For any `CopySpec` involved in copying files, may it be the `Copy` task itself, or any child specifications, you can explicitly set the permissions the destination files will have via the link:{javadocPath}/org/gradle/api/file/CopyProcessingSpec.html#filePermissions-org.gradle.api.Action-[CopySpec.filePermissions {}] configurations block.

=== Using `CopySpec.dirPermissions{}`

You can do the same for directories too, independently of files, via the link:{javadocPath}/org/gradle/api/file/CopyProcessingSpec.html#dirPermissions-org.gradle.api.Action-[CopySpec.dirPermissions {}] configurations block.

NOTE: Not setting permissions explicitly will preserve the permissions of the original files or directories.

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=file-permissions]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=file-permissions]"]
====

For a detailed description of file permissions, see link:{javadocPath}/org/gradle/api/file/FilePermissions.html[FilePermissions] and link:{javadocPath}/org/gradle/api/file/UserClassFilePermissions.html[UserClassFilePermissions].
For details on the convenience method used in the samples, see link:{javadocPath}/org/gradle/api/file/ConfigurableFilePermissions.html#unix-java.lang.String-[ConfigurableFilePermissions.unix(String)].

Using empty configuration blocks for file or directory permissions still sets them explicitly, just to fixed default values.
Everything inside one of these configuration blocks is relative to the default values.
Default permissions differ for files and directories:

* *file*: read & write for *owner*, read for *group*, read for *other* (*0644*, *rw-r--r--*)
* *directory*: read, write & execute for *owner*, read & execute for *group*, read & execute for *other* (*0755*, *rwxr-xr-x*)

[[sec:moving_files_example]]
== Moving files and directories

Moving files and directories in Gradle is a straightforward process that can be accomplished using several APIs.
When implementing file-moving logic in your build scripts, it's important to consider file paths, conflicts, and task dependencies.

=== Using `File.renameTo()`

`File.renameTo()` is a method in Java (and by extension, in Gradle's Groovy DSL) used to rename or move a file or directory.
When you call `renameTo()` on a `File` object, you provide another `File` object representing the new name or location.
If the operation is successful, `renameTo()` returns `true`; otherwise, it returns `false`.

It's important to note that `renameTo()` has some limitations and platform-specific behavior.

In this example, the `moveFile` task uses the `Copy` task type to specify the source and destination directories.
Inside the `doLast` closure, it uses `File.renameTo()` to move the file from the source directory to the destination directory:

[source,groovy]
----
task moveFile {
    doLast {
        def sourceFile = file('source.txt')
        def destFile = file('destination/new_name.txt')

        if (sourceFile.renameTo(destFile)) {
            println "File moved successfully."
        }
    }
}

----

=== Using the `Copy` task

In this example, the `moveFile` task copies the file `source.txt` to the destination directory and renames it to `new_name.txt` in the process.
This achieves a similar effect to moving a file.

[source,groovy]
----
task moveFile(type: Copy) {
    from 'source.txt'
    into 'destination'
    rename { fileName ->
        'new_name.txt'
    }
}
----

[[sec:deleting_files_example]]
== Deleting files and directories

Deleting files and directories in Gradle involves removing them from the file system.

=== Using the `Delete` task

You can easily delete files and directories using the link:{groovyDslPath}/org.gradle.api.tasks.Delete.html[Delete] task.
You must specify which files and directories to delete in a way supported by the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[Project.files(java.lang.Object...)] method.

For example, the following task deletes the entire contents of a build's output directory:

====
include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-example]"]
include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-example]"]
====

If you want more control over which files are deleted, you can't use inclusions and exclusions the same way you use them for copying files.
Instead, you use the built-in filtering mechanisms of `FileCollection` and `FileTree`.
The following example does just that to clear out temporary files from a source directory:

====
include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-with-filter-example]"]
include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-with-filter-example]"]
====

=== Using `Project.delete()`

The link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:delete(org.gradle.api.Action)[Project.delete(org.gradle.api.Action)] method can delete files and directories.

This method takes one or more arguments representing the files or directories to be deleted.

For example, the following task deletes the entire contents of a build's output directory:

====
include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-example]"]
include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-example]"]
====

If you want more control over which files are deleted, you can't use inclusions and exclusions the same way you use them for copying files.
Instead, you use the built-in filtering mechanisms of `FileCollection` and `FileTree`.
The following example does just that to clear out temporary files from a source directory:

====
include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-with-filter-example]"]
include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-with-filter-example]"]
====

[[sec:creating_archives_example]]
== Creating archives

From the perspective of Gradle, packing files into an archive is effectively a copy in which the destination is the archive file rather than a directory on the file system.
Creating archives looks a lot like copying, with all the same features.

=== Using the `Zip`, `Tar`, or `Jar` task

The simplest case involves archiving the entire contents of a directory, which this example demonstrates by creating a ZIP of the `toArchive` directory:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=create-archive-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=create-archive-example]"]
====

Notice how we specify the destination and name of the archive instead of an `into()`: both are required. You often won't see them explicitly set because most projects apply the <<base_plugin.adoc#base_plugin,Base Plugin>>.
It provides some conventional values for those properties.

The following example demonstrates this; you can learn more about the conventions in the <<#sec:archive_naming,archive naming>> section.

Each type of archive has its own task type, the most common ones being link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html[Zip], link:{groovyDslPath}/org.gradle.api.tasks.bundling.Tar.html[Tar] and link:{groovyDslPath}/org.gradle.api.tasks.bundling.Jar.html[Jar].
They all share most of the configuration options of `Copy`, including filtering and renaming.

One of the most common scenarios involves copying files into specified archive subdirectories.
For example, let's say you want to package all PDFs into a `docs` directory in the archive's root.
This `docs` directory doesn't exist in the source location, so you must create it as part of the archive.
You do this by adding an `into()` declaration for just the PDFs:

====
include::sample[dir="snippets/files/archivesWithBasePlugin/kotlin",files="build.gradle.kts[tags=create-archive-with-base-plugin-example]"]
include::sample[dir="snippets/files/archivesWithBasePlugin/groovy",files="build.gradle[tags=create-archive-with-base-plugin-example]"]
====

As you can see, you can have multiple `from()` declarations in a copy specification, each with its own configuration.
See <<#sub:using_child_copy_specifications,Using child copy specifications>> for more information on this feature.

[[sec:archives]]
=== Understanding archive creation

Archives are essentially self-contained file systems, and Gradle treats them as such.
This is why working with archives is similar to working with files and directories.

Out of the box, Gradle supports the creation of ZIP and TAR archives and, by extension, Java's JAR, WAR, and EAR formats—Java's archive formats are all ZIPs.
Each of these formats has a corresponding task type to create them: link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html[Zip], link:{groovyDslPath}/org.gradle.api.tasks.bundling.Tar.html[Tar], link:{groovyDslPath}/org.gradle.api.tasks.bundling.Jar.html[Jar], link:{groovyDslPath}/org.gradle.api.tasks.bundling.War.html[War], and link:{groovyDslPath}/org.gradle.plugins.ear.Ear.html[Ear].
These all work the same way and are based on copy specifications, just like the `Copy` task.

Creating an archive file is essentially a file copy in which the destination is implicit, i.e., the archive file itself.
Here is a basic example that specifies the path and name of the target archive file:

====
include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=create-archive-example]"]
include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=create-archive-example]"]
====

The full power of copy specifications is available to you when creating archives, which means you can do content filtering, file renaming, or anything else covered in the previous section.
A common requirement is copying files into subdirectories of the archive that don't exist in the source folders, something that can be achieved with `into()` <<#sub:using_child_copy_specifications,child specifications>>.

Gradle allows you to create as many archive tasks as you want, but it's worth considering that many convention-based plugins provide their own.
For example, the Java plugin adds a `jar` task for packaging a project's compiled classes and resources in a JAR.
Many of these plugins provide sensible conventions for the names of archives and the copy specifications used.
We recommend you use these tasks wherever you can rather than overriding them with your own.

[[sec:archive_naming]]
=== Naming archives

Gradle has several conventions around the naming of archives and where they are created based on the plugins your project uses.
The main convention is provided by the <<base_plugin.adoc#base_plugin,Base Plugin>>, which defaults to creating archives in the `layout.buildDirectory.dir("distributions")` directory and typically uses archive names of the form _[projectName]-[version].[type]_.

The following example comes from a project named `archive-naming`, hence the `myZip` task creates an archive named `archive-naming-1.0.zip`:

====
include::sample[dir="snippets/files/archiveNaming/kotlin",files="build.gradle.kts[tags=zip-task]"]
include::sample[dir="snippets/files/archiveNaming/groovy",files="build.gradle[tags=zip-task]"]
====

----
$ gradle -q myZip
include::{snippetsPath}/files/archiveNaming/tests/archiveNaming.out[]
----

Note that the archive name does _not_ derive from the task's name that creates it.

If you want to change the name and location of a generated archive file, you can provide values for the corresponding task's `archiveFileName` and `destinationDirectory` properties.
These override any conventions that would otherwise apply.

Alternatively, you can make use of the default archive name pattern provided by link:{groovyDslPath}/org.gradle.api.tasks.bundling.AbstractArchiveTask.html#org.gradle.api.tasks.bundling.AbstractArchiveTask:archiveFileName[AbstractArchiveTask.getArchiveFileName()]: _[archiveBaseName]-[archiveAppendix]-[archiveVersion]-[archiveClassifier].[archiveExtension]_.
You can set each of these properties on the task separately.
Note that the Base Plugin uses the convention of the project name for _archiveBaseName_, project version for _archiveVersion_, and the archive type for _archiveExtension_.
It does not provide values for the other properties.

This example — from the same project as the one above — configures just the `archiveBaseName` property, overriding the default value of the project name:

====
include::sample[dir="snippets/files/archiveNaming/kotlin",files="build.gradle.kts[tags=zip-task-with-custom-base-name]"]
include::sample[dir="snippets/files/archiveNaming/groovy",files="build.gradle[tags=zip-task-with-custom-base-name]"]
====

----
$ gradle -q myCustomZip
include::{snippetsPath}/files/archiveNaming/tests/zipWithCustomName.out[]
----

You can also override the default `archiveBaseName` value for _all_ the archive tasks in your build by using the _project_ property `archivesBaseName`, as demonstrated by the following example:

====
include::sample[dir="snippets/files/archivesChangedBaseName/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/files/archivesChangedBaseName/groovy",files="build.gradle[]"]
====

----
$ gradle -q echoNames
include::{snippetsPath}/files/archivesChangedBaseName/tests/zipWithArchivesBaseName.out[]
----

You can find all the possible archive task properties in the API documentation for link:{groovyDslPath}/org.gradle.api.tasks.bundling.AbstractArchiveTask.html[AbstractArchiveTask].
Still, we have also summarized the main ones here:

`archiveFileName` — `Property<String>`, default: `__archiveBaseName__-__archiveAppendix__-__archiveVersion__-__archiveClassifier__.__archiveExtension__`::
The complete file name of the generated archive. If any of the properties in the default value are empty, their '-' separator is dropped.

`archiveFile` — `Provider<RegularFile>`, _read-only_, default: `__destinationDirectory__/__archiveFileName__`::
The absolute file path of the generated archive.

`destinationDirectory` — `DirectoryProperty`, default: depends on archive type::
The target directory in which to put the generated archive. By default, JARs and WARs go into `layout.buildDirectory.dir("libs")`. ZIPs and TARs go into `layout.buildDirectory.dir("distributions")`.

`archiveBaseName` — `Property<String>`, default: `__project.name__`::
The base name portion of the archive file name, typically a project name or some other descriptive name for what it contains.

`archiveAppendix` — `Property<String>`, default: `null`::
The appendix portion of the archive file name that comes immediately after the base name. It is typically used to distinguish between different forms of content, such as code and docs, or a minimal distribution versus a full or complete one.

`archiveVersion` — `Property<String>`, default: `__project.version__`::
The version portion of the archive file name, typically in the form of a normal project or product version.

`archiveClassifier` — `Property<String>`, default: `null`::
The classifier portion of the archive file name. Often used to distinguish between archives that target different platforms.

`archiveExtension` — `Property<String>`, default: depends on archive type and compression type::
The filename extension for the archive. By default, this is set based on the archive task type and the compression type (if you're creating a TAR). Will be one of: `zip`, `jar`, `war`, `tar`, `tgz` or `tbz2`. You can of course set this to a custom extension if you wish.

[[sec:sharing_content_between_multiple_archives]]
=== Sharing content between multiple archives

<<#sub:sharing_copy_specs,As described in the `CopySpec` section above>>, you can use the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:copySpec(org.gradle.api.Action)[Project.copySpec(org.gradle.api.Action)] method to share content between archives.

[[sec:archive_contents]]
=== Using archives as file trees

An archive is a directory and file hierarchy packed into a single file.
In other words, it's a special case of a file tree, and that's exactly how Gradle treats archives.

Instead of using the `fileTree()` method, which only works on normal file systems, you use the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)[Project.zipTree(java.lang.Object)] and link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)[Project.tarTree(java.lang.Object)] methods to wrap archive files of the corresponding type (note that JAR, WAR and EAR files are ZIPs).
Both methods return `FileTree` instances that you can then use in the same way as normal file trees.
For example, you can extract some or all of the files of an archive by copying its contents to some directory on the file system.
Or you can merge one archive into another.

Here are some simple examples of creating archive-based file trees:

====
include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=archive-trees]"]
include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=archive-trees]"]
====

You can see a practical example of extracting an archive file <<#sec:unpacking_archives_example,in the unpacking archives section>> below.

[[sec:reproducible_archives]]
=== Using `AbstractArchiveTask` for reproducible builds

Sometimes it's desirable to recreate archives exactly the same, byte for byte, on different machines.
You want to be sure that building an artifact from source code produces the same result no matter when and where it is built.
This is necessary for projects like https://reproducible-builds.org/[reproducible-builds.org].

Reproducing the same byte-for-byte archive poses some challenges since the order of the files in an archive is influenced by the underlying file system.
Each time a ZIP, TAR, JAR, WAR or EAR is built from source, the order of the files inside the archive may change.
Files that only have a different timestamp also causes differences in archives from build to build.

All link:{groovyDslPath}/org.gradle.api.tasks.bundling.AbstractArchiveTask.html[AbstractArchiveTask] (e.g. Jar, Zip) tasks shipped with Gradle include support for producing reproducible archives.

For example, to make a `Zip` task reproducible you need to set link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:reproducibleFileOrder[Zip.isReproducibleFileOrder()] to `true` and link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:preserveFileTimestamps[Zip.isPreserveFileTimestamps()] to `false`.
In order to make all archive tasks in your build reproducible, consider adding the following configuration to your build file:

====
include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=reproducible]"]
include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=reproducible]"]
====

Often you will want to publish an archive, so that it is usable from another project.

[[sec:unpacking_archives_example]]
== Unpacking archives

Archives are effectively self-contained file systems, so unpacking them is a case of copying the files from that file system onto the local file system — or even into another archive.
Gradle enables this by providing some wrapper functions that make archives available as hierarchical collections of files (<<sec:file_trees,file trees>>).

=== Using `Project.zipTree` and `Project.tarTree`

The two functions of interest are link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)[Project.zipTree(java.lang.Object)] and link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)[Project.tarTree(java.lang.Object)], which produce a link:{javadocPath}/org/gradle/api/file/FileTree.html[FileTree] from a corresponding archive file.

That file tree can then be used in a `from()` specification, like so:

====
include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=unpack-archive-example]"]
include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=unpack-archive-example]"]
====

As with a normal copy, you can control which files are unpacked via <<#sec:filtering_files,filters>> and even <<#sec:renaming_files,rename files>> as they are unpacked.

More advanced processing can be handled by the link:{groovyDslPath}/org.gradle.api.tasks.AbstractCopyTask.html#eachFile(org.gradle.api.Action)[eachFile()] method.
For example, you might need to extract different subtrees of the archive into different paths within the destination directory.
The following sample uses the method to extract the files within the archive's `libs` directory into the root destination directory, rather than into a `libs` subdirectory:

====
include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=unpack-archive-subset-example]"]
include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=unpack-archive-subset-example]"]
====
<1> Extracts only the subset of files that reside in the `libs` directory
<2> Remaps the path of the extracting files into the destination directory by dropping the `libs` segment from the file path
<3> Ignores the empty directories resulting from the remapping, see Caution note below

[CAUTION]
====
You can not change the destination path of empty directories with this technique.
You can learn more in https://github.com/gradle/gradle/issues/2940[this issue].
====

If you're a Java developer wondering why there is no `jarTree()` method, that's because `zipTree()` works perfectly well for JARs, WARs, and EARs.

[[sec:creating_uber_jar_example]]
== Creating "uber" or "fat" JARs

In Java, applications and their dependencies were typically packaged as separate JARs within a single distribution archive.
That still happens, but another approach that is now common is placing the classes and resources of the dependencies directly into the application JAR, creating what is known as an Uber or fat JAR.

Creating "uber" or "fat" JARs in Gradle involves packaging all dependencies into a single JAR file, making it easier to distribute and run the application.

=== Using the Shadow Plugin

Gradle does not have full built-in support for creating uber JARs, but you can use third-party plugins like the https://github.com/GradleUp/shadow[Shadow plugin] (`com.gradleup.shadow`) to achieve this.
This plugin packages your project classes and dependencies into a single JAR file.

=== Using `Project.zipTree()` and the `Jar` task

To copy the contents of other JAR files into the application JAR, use the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)[Project.zipTree(java.lang.Object)] method and the link:{groovyDslPath}/org.gradle.api.tasks.bundling.Jar.html[Jar] task.
This is demonstrated by the `uberJar` task in the following example:

====
include::sample[dir="snippets/files/archivesWithJavaPlugin/kotlin",files="build.gradle.kts[tags=create-uber-jar-example]"]
include::sample[dir="snippets/files/archivesWithJavaPlugin/groovy",files="build.gradle[tags=create-uber-jar-example]"]
====

In this case, we're taking the runtime dependencies of the project — `configurations.runtimeClasspath.files` — and wrapping each of the JAR files with the `zipTree()` method.
The result is a collection of ZIP file trees, the contents of which are copied into the uber JAR alongside the application classes.

[[sec:creating_directories_example]]
== Creating directories

Many tasks need to create directories to store the files they generate, which is why Gradle <<incremental_build.adoc#incremental_build,automatically manages>> this aspect of tasks when they explicitly define file and directory outputs.
All core Gradle tasks ensure that any output directories they need are created, if necessary, using this mechanism.

=== Using `File.mkdirs` and `Files.createDirectories`

In cases where you need to create a directory manually, you can use the standard `{javaApi}/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute++...++-[Files.createDirectories]` or `{javaApi}/java/io/File.html#mkdirs--[File.mkdirs]` methods from within your build scripts or custom task implementations.

Here is a simple example that creates a single `images` directory in the project folder:

====
include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=mkdir-example]"]
include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=mkdir-example]"]
====

As described in the {antManual}/Tasks/mkdir.html[Apache Ant manual], the `mkdir` task will automatically create all necessary directories in the given path.
It will do nothing if the directory already exists.

=== Using `Project.mkdir`

You can create directories in Gradle using the `mkdir` method, which is available in the link:{javadocPath}/org/gradle/api/Project.html#mkdir-java.lang.Object-[`Project` object].
This method takes a `File` object or a `String` representing the path of the directory to be created:

[source,groovy]
----
tasks.register('createDirs') {
    doLast {
        mkdir 'src/main/resources'
        mkdir file('build/generated')

        // Create multiple dirs
        mkdir files(['src/main/resources', 'src/test/resources'])

        // Check dir existence
        def dir = file('src/main/resources')
        if (!dir.exists()) {
            mkdir dir
        }
    }
}
----

[[sec:install_executable]]
== Installing executables

When you are building a standalone executable, you may want to install this file on your system, so it ends up in your path.

=== Using the `Copy` task

You can use a `Copy` task to install the executable into shared directories like `/usr/local/bin`.
The installation directory probably contains many other executables, some of which may even be unreadable by Gradle.
To support the unreadable files in the `Copy` task's destination directory and to avoid time consuming up-to-date checks, you can use link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doNotTrackState(java.lang.String)[Task.doNotTrackState()]:

====
include::sample[dir="snippets/files/installExecutable/kotlin",files="build.gradle.kts"]
include::sample[dir="snippets/files/installExecutable/groovy",files="build.gradle"]
====

[[sec:copy_deploy]]
== Deploying single files into application servers

Deploying a single file to an application server typically refers to the process of transferring a packaged application artifact, such as a WAR file, to the application server's deployment directory.

=== Using the `Copy` task

When working with application servers, you can use a `Copy` task to deploy the application archive (e.g. a WAR file).
Since you are deploying a single file, the destination directory of the `Copy` is the whole deployment directory.
The deployment directory sometimes does contain unreadable files like named pipes, so Gradle may have problems doing up-to-date checks.
In order to support this use-case, you can use link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doNotTrackState(java.lang.String)[Task.doNotTrackState()]:

====
include::sample[dir="snippets/files/deployWarWithCopy/kotlin",files="build.gradle.kts"]
include::sample[dir="snippets/files/deployWarWithCopy/groovy",files="build.gradle"]
====
