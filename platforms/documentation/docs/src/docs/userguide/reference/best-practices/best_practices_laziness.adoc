// Copyright (C) 2025 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[best_practices_for_laziness]]
= Best Practices for Laziness

[[map_versus_flatmap]]
== Be Careful with `map` vs. `flatMap` when Wiring Properties

When wiring task outputs to inputs, several common patterns break task dependency tracking or cause configuration-time failures.
Understanding when to use `map`, `flatMap`, and how to avoid creating "naked providers" is essential for reliable builds.

=== Explanation

Gradle's Provider API uses `map` and `flatMap` to transform and connect task properties.
However, certain patterns break the connection between tasks, causing builds to fail or produce incorrect results.

The confusion often arises when using a mix of eager properties (like `File`) and lazy properties (like `RegularFileProperty`):

- For **eager properties**, you use `map` to extract the value
- For **lazy properties**, you use `flatMap` to extract the Provider

When unsure which to use, developers often resort to `.get()` or create new providers with `provider {}`.
These "naked providers" have no dependency information and break dependency tracking.

When wiring task outputs to inputs:

1. **Use directly annotated output properties** - avoid deriving properties through `.map {}`
2. **Use `flatMap` to extract Provider properties** - this is correct and necessary for the Provider API
3. **Use `map` to extract eager properties** - extract plain values like `File` or `String`, not Provider properties
4. **Chain `map` to transform values** - don't create new providers with `provider {}`
5. **Never call `.get()` to read file content in callbacks** - the file doesn't exist yet at configuration time
6. **For derived properties, use `.map { it.property.get() }` as a workaround** - but prefer direct annotations

NOTE: For dependency tracking to work, task output properties must be properly annotated with `@OutputFile`, `@OutputDirectory`, or similar annotations. Without these annotations, Gradle cannot track task dependencies.

==== Don't Do This

===== Creating Naked Providers with `provider {}`

This is the most common mistake.
Creating a new provider inside `flatMap` loses all dependency information:

[source,kotlin]
----
val generator = tasks.register<GeneratorTask>("generator") {
    outputFile.set(layout.buildDirectory.file("output.txt"))
}

tasks.register<ConsumerTask>("consumer") {
    // BROKEN: Creating provider {} inside flatMap creates a "naked provider"
    // The resulting provider has NO knowledge of the 'generator' task
    inputContent.set(generator.flatMap {
        provider { it.outputFile.get().asFile.readText() }
    })
}
----

The `provider {}` factory creates a new provider with no connection to any task.
Gradle cannot determine that this provider depends on the `generator` task.

Instead, you should chain `map` on the Provider itself:

[source,kotlin]
----
tasks.register<ConsumerTask>("consumer") {
    // CORRECT: Chain map on the Provider to transform the value
    inputContent.set(
        generator.flatMap { it.outputFile }
                 .map { it.asFile.readText() }
    )
}
----

==== Reading File Content at Configuration Time

Calling `.get()` to read file content fails immediately because the file doesn't exist yet:

[source,kotlin]
----
val generator = tasks.register<GeneratorTask>("generator") {
    outputFile.set(layout.buildDirectory.file("output.txt"))
}

tasks.register<ConsumerTask>("consumer") {
    // BROKEN: Tries to read the file at configuration time
    // The file doesn't exist yet - generator hasn't run!
    inputContent.set(generator.map {
        it.outputFile.get().asFile.readText() // FAILS HERE
    })
}
----

The `map` callback executes at configuration time (when setting up the build).
The file won't exist until the `generator` task runs during execution time.

This pattern also breaks Configuration Cache because file content cannot be serialized.

Instead, use lazy evaluation by chaining `map` on the Provider:

[source,kotlin]
----
tasks.register<ConsumerTask>("consumer") {
    // CORRECT: The file is read lazily when the task executes
    inputContent.set(
        generator.flatMap { it.outputFile }
                 .map { it.asFile.readText() } // Evaluated at execution time
    )
}
----

==== Using `flatMap` on Derived Properties

Using `flatMap` to extract properties that are themselves derived through `.map {}` can lose the task dependency:

[source,kotlin]
----
abstract class ProducerTask @Inject constructor(
    objectFactory: ObjectFactory
) : DefaultTask() {
    @get:Internal
    val someDirectory = objectFactory.directoryProperty()

    // This property is DERIVED via map - not directly annotated
    @get:OutputFile
    val outputFile = someDirectory.map { it.file("output.txt") }

    @TaskAction
    fun execute() {
        outputFile.get().asFile.writeText("content")
    }
}

val producer = tasks.register<ProducerTask>("producer") {
    someDirectory.set(layout.buildDirectory.dir("output"))
}

tasks.register<Sync>("consumer") {
    // BROKEN: flatMap on a derived property may lose the task dependency
    from(producer.flatMap { it.outputFile })
    into(layout.buildDirectory.dir("sync"))
}
----

When the output property is derived through `.map {}`, `flatMap` may extract the mapped provider without preserving the connection to the original task.

Instead, use `.map { it.property.get() }` to preserve the dependency:

[source,kotlin]
----
tasks.register<Sync>("consumer") {
    // WORKAROUND: Using map with .get() preserves the dependency
    from(producer.map { it.outputFile.get() })
    into(layout.buildDirectory.dir("sync"))
}
----

Or use directly annotated properties instead of derived ones:

[source,kotlin]
----
abstract class ProducerTask : DefaultTask() {
    // Directly annotated property - not derived
    @get:OutputFile
    abstract val outputFile: RegularFileProperty

    @TaskAction
    fun execute() {
        outputFile.get().asFile.writeText("content")
    }
}

val producer = tasks.register<ProducerTask>("producer") {
    outputFile.set(layout.buildDirectory.file("output/output.txt"))
}

tasks.register<Sync>("consumer") {
    // CORRECT: flatMap works reliably with directly annotated properties
    from(producer.flatMap { it.outputFile })
    into(layout.buildDirectory.dir("sync"))
}
----

==== Do This Instead

===== Extracting Provider Properties with `flatMap`

Use `flatMap` when extracting a Provider property from a task - this is the correct and necessary approach:

[source,kotlin]
----
abstract class GeneratorTask : DefaultTask() {
    @get:OutputFile
    abstract val outputFile: RegularFileProperty

    @TaskAction
    fun generate() {
        outputFile.get().asFile.writeText("Generated content")
    }
}

val generator = tasks.register<GeneratorTask>("generator") {
    outputFile.set(layout.buildDirectory.file("output.txt"))
}

tasks.register<ConsumerTask>("consumer") {
    // CORRECT: flatMap extracts the Provider property
    // The dependency on 'generator' is preserved
    inputFile.set(generator.flatMap { it.outputFile })
}
----

===== Extracting Eager Properties with `map`

Use `map` when extracting plain (non-Provider) values from tasks:

[source,kotlin]
----
abstract class LegacyTask : DefaultTask() {
    // Old-style eager property (before Provider API)
    @get:OutputDirectory
    lateinit var destinationDir: File

    @TaskAction
    fun execute() {
        destinationDir.mkdirs()
        File(destinationDir, "output.txt").writeText("content")
    }
}

val legacy = tasks.register<LegacyTask>("legacy") {
    destinationDir = layout.buildDirectory.dir("docs").get().asFile
}

tasks.register<ConsumerTask>("consumer") {
    // CORRECT: Use map for eager (non-Provider) properties
    inputDir.set(legacy.map { it.destinationDir })
}
----

===== Chaining Transformations

Chain `map` calls to transform Provider values without breaking dependency tracking:

[source,kotlin]
----
val generator = tasks.register<GeneratorTask>("generator") {
    outputFile.set(layout.buildDirectory.file("output.txt"))
}

tasks.register<ConsumerTask>("consumer") {
    // CORRECT: Chain transformations on the Provider itself
    // First flatMap extracts the Provider, then map transforms it
    inputContent.set(
        generator.flatMap { it.outputFile }
                 .map { it.asFile.readText() }
                 .map { it.uppercase() }
    )
}
----

=== References

- <<lazy_configuration.adoc#sec:working_with_task_output_properties,Working with Task Output Properties>>

=== Tags

`<<tags_reference.adoc#tag:task-configuration-avoidance,#task-configuration-avoidance>>`
