// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[composite_builds]]
= Composite Builds (Included Builds)
:keywords: composite build, included build

A composite build is a build that includes other builds.

[[composite_build_intro]]
A composite build (also known as an included build) is similar to a Gradle multi-project build, except that instead of including `subprojects`, entire `builds` are included.

This is done either using the `settings.gradle(.kts)` file and adding a build using `includeBuild()`:

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="settings.gradle.kts[tags=inc]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="settings.gradle[tags=inc]"]
====

Or using the CLI flag `--include-build`:

[source,bash]
----
$ ./gradlew build --include-build my-utils
----

WARNING: Including a build via `includeBuild` or the `--include-build` CLI flag only provides project dependencies. To share plugins from a composite build, you must include the build within the `pluginManagement {}` block of your `settings.gradle(.kts)` file.

[[defining_composite_builds]]
== Composite Build Layout

Composite builds allow you to:

* Combine builds that are usually developed independently, for instance, when trying out a bug fix in a library that your application uses.
* Decompose a large multi-project build into smaller, more isolated chunks that can be worked on independently or together as needed.

A build that is included in a composite build is referred to as an *included build*.

image::structuring-builds-4.png[]

Included builds do not share any configuration with other included builds.
*Each included build is configured and executed in isolation*.

The following example demonstrates how two Gradle builds, normally developed separately, can be combined into a composite build:

[.multi-language-sample]
=====
[source, kotlin]
----
my-composite
├── settings.gradle.kts
├── build.gradle.kts
├── my-app
│   ├── settings.gradle.kts
│   └── app
│       ├── build.gradle.kts
│       └── src/main/java/org/sample/my-app/Main.java
└── my-utils
    ├── settings.gradle.kts
    ├── number-utils
    │   ├── build.gradle.kts
    │   └── src/main/java/org/sample/numberutils/Numbers.java
    └── string-utils
        ├── build.gradle.kts
        └── src/main/java/org/sample/stringutils/Strings.java
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
my-composite
├── settings.gradle
├── build.gradle
├── my-app
│   ├── settings.gradle
│   └── app
│       ├── build.gradle
│       └── src/main/java/org/sample/my-app/Main.java
└── my-utils
    ├── settings.gradle
    ├── number-utils
    │   ├── build.gradle
    │   └── src/main/java/org/sample/numberutils/Numbers.java
    └── string-utils
        ├── build.gradle
        └── src/main/java/org/sample/stringutils/Strings.java
----
=====

The `my-utils` multi-project build produces two Java libraries, `number-utils` and `string-utils`.
The `my-app` build produces an executable using functions from those libraries.

The `my-app` build does not depend directly on `my-utils`.
Instead, it declares binary dependencies on the libraries produced by `my-utils`:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/samples/build-organization/composite-builds/basic">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="my-app/app/build.gradle.kts[tags=app_dependencies]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="my-app/app/build.gradle[tags=app_dependencies]"]
====

[[composite_build_isolation]]
=== Isolation and Configuration Inheritance

A critical aspect of included builds is that they are executed in isolation.

This has specific implications for how configuration is (or is not) shared:

- *Gradle Properties*: `gradle.properties` files defined in the root build are not visible to included builds. Each included build must define its own properties.
- *Project Properties*: Gradle project properties passed via the CLI (e.g., `-PmyProperty=value`) are only applied to the root build and are not passed to included builds.
- *Shared Configuration*: Included builds do not share any configuration with the root build or other included builds. This includes repositories, plugin management, or dependency versions defined in `buildSrc` or version catalogs.

If you need to share credentials (like repository tokens) or common configuration across a composite build tree, consider using system environment variables or extracting the logic into a shared convention plugin included via `pluginManagement`.

While included builds are isolated and cannot declare direct project dependencies, a composite build can <<#included_build_task_dependencies,declare task dependencies>> on its included builds.

[[settings_defined_composite]]
== Defining a Composite Build via the Settings file

It's possible to make the above arrangement persistent by using link:{groovyDslPath}/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)[Settings.includeBuild(java.lang.Object)] to declare the included build in the `settings.gradle(.kts)` file.

The settings file can be used to add subprojects and included builds simultaneously.

Included builds are added by location:

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="settings.gradle.kts[tags=inc]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="settings.gradle[tags=inc]"]
====

[[separate_composite]]
In the example, the settings.gradle(.kts) file combines otherwise separate builds:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/samples/build-organization/composite-builds/basic">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="settings.gradle.kts[]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="settings.gradle[]"]
====

To execute the `run` task in the `my-app` build from `my-composite`, run `./gradlew my-app:app:run`.

You can optionally define a `run` task in `my-composite` that depends on `my-app:app:run` so that you can execute `./gradlew run`:

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="build.gradle.kts[tags=run]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="build.gradle[tags=run]"]
====

[[command_line_composite]]
== Defining a Composite Build via `--include-build`

The `--include-build` command-line argument turns the executed build into a composite, substituting dependencies from the included build into the executed build.

For example, the output of `./gradlew run --include-build ../my-utils` run from `my-app`:

----
$ ./gradlew --include-build ../my-utils run
include::{samplesPath}/build-organization/composite-builds/basic/tests/basicCli.out[]
----

[[referencing_included_build_projects]]
== Referencing Projects in Composite Builds

It is a common mistake to attempt to use `project()` notation to depend on a module that resides in an included build.

IMPORTANT: Included builds are not subprojects.

Each build in a composite remains a separate project hierarchy.
You cannot use project paths (e.g., `project(":other-build:module")`) to reference a project across build boundaries.
Doing so will result in an `UnknownProjectException`.

To depend on a project from an included build, you must use its external coordinates (the same coordinates you would use if the library were published to Maven Central or Ivy).

If an included build has a project with `group = "com.example.data"` and `rootProject.name = "core-schema"`, you reference it in your main build like an external dependency.
For example, if your configuration looks as follows:

[source,text]
----
.
├── app (Main Build)
│   ├── build.gradle.kts
│   └── settings.gradle.kts  <-- includeBuild("../core-schema")
└── core-schema (Included Build)
    ├── build.gradle.kts
    └── settings.gradle.kts  <-- rootProject.name = "core-schema"
----

The included build has the following information:

[source,kotlin]
.core-schema/build.gradle.kts
----
group = "com.example.data"
version = "1.0.0"
----

So that the main build can reference it:

[source,kotlin]
.app/build.gradle.kts
----
dependencies {
    // WRONG: This will fail because ":core-schema" is not in this build's hierarchy
    implementation(project(":core-schema"))

    // CORRECT: Gradle sees this GAV and finds the matching project in the included build
    implementation("com.example.data:core-schema:1.0.0")
}
----

Gradle uses the metadata from the included build to "discover" which coordinates it provides.
As long as the coordinates match, Gradle replaces the external dependency with a project dependency at execution time.

[[included_plugin_builds]]
== Composite builds for dependencies versus Composite Builds for plugins

When using composite builds, there is a significant distinction between including a build for dependencies versus including a build for plugins.

Passing `--include-build <path>` via the command line (or using `includeBuild("<path>")` in `settings.gradle(.kts)`) only makes the subproject's software components (libraries) available to the main build.
It does not search the included build for Gradle plugins.

If your included build contains precompiled script plugins or custom plugin logic, the main build will fail with a `Plugin [id: '...'] was not found` error, even if the path is correctly included.

If you run a command like:

[source,bash]
----
$ ./gradlew build --include-build my-conventions-plugin
----

You will receive an error similar to:

[source,bash]
----
What went wrong: Plugin [id: 'my.custom.convention.plugin'] was not found in any of the following sources...
----

To successfully include a build that provides plugins, you must declare it explicitly in your `settings.gradle(.kts)` file inside the `pluginManagement {}` block. *Command-line flags cannot currently satisfy plugin requirements.*

[source,kotlin]
----
pluginManagement {
    includeBuild("my-conventions-plugin") // This makes plugins available to the build
}
----

Using this mechanism, the included build may also contribute a settings plugin that can be applied in the settings file itself:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/snippets/developingPlugins/testingPlugins">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/include-plugin-build",files="settings.gradle.kts[tags=include-build]"]
include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/include-plugin-build",files="settings.gradle[tags=include-build]"]
====

[[included_builds]]
== Restrictions on Composite Builds

Composite builds must maintain unique identifiers for every project across the entire build tree.

To prevent conflicts, Gradle qualifies projects using a build-tree path, which combines the build path (derived from the included build's directory name) and the project path.

To ensure every project remains uniquely addressable, included builds must satisfy two conditions:

1. *Unique Build Paths:* No two included builds can share the same build path.
2. *No Namespace Overlap:* An included build path cannot conflict with any existing project path in the root build.

If directory names cause a naming collision, rename the build path in your settings file:

.settings.gradle.kts
[source,kotlin]
----
includeBuild("some-included-build") {
    name = "other-name"
}
----

NOTE: When a composite build includes another composite, Gradle flattens the structure. All included builds share the same parent, regardless of how deeply they were nested.

[[current_limitations_and_future_work]]
== Limitations of Composite Builds

Limitations of the current implementation include:

* No support for included builds with publications that don't mirror the project default configuration. +
See <<#included_build_substitution_limitations,Cases where composite builds won't work>>.
* Multiple composite builds may conflict when run in parallel if more than one includes the same build. +
Gradle does not share the project lock of a shared composite build between Gradle invocations to prevent concurrent execution.

[[interacting_with_composite_builds]]
== Interacting with a Composite Build

Interacting with a composite build is generally similar to a regular multi-project build.
Tasks can be executed, tests can be run, and builds can be imported into the IDE.

[[composite_build_executing_tasks]]
=== Executing tasks

Tasks from an included build can be executed from the command-line or IDE in the same way as tasks from a regular multi-project build.
Executing a task will result in task dependencies being executed, as well as those tasks required to build dependency artifacts from other included builds.

You can call a task in an included build using a fully qualified path, for example, `:included-build-name:project-name:taskName`.
Project and task names can be <<command_line_interface.adoc#sec:name_abbreviation,abbreviated>>.

----
$ ./gradlew :included-build:subproject-a:compileJava
> Task :included-build:subproject-a:compileJava

$ ./gradlew :i-b:sA:cJ
> Task :included-build:subproject-a:compileJava
----

To <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,exclude a task from the command line>>, you need to provide the fully qualified path to the task.

NOTE: Included build tasks are automatically executed to generate required dependency artifacts, or the <<#included_build_task_dependencies,including build can declare a dependency on a task from an included build>>.

[[composite_build_ide_integration]]
=== Importing into the IDE

One of the most useful features of composite builds is IDE integration.

Importing a composite build permits sources from separate Gradle builds to be easily developed together.
For every included build, each subproject is included as an IntelliJ IDEA Module or Eclipse Project.
Source dependencies are configured, providing cross-build navigation and refactoring.

[[included_build_declaring_substitutions]]
== Declaring dependencies substituted by a Composite Build

By default, Gradle will configure each included build to determine the dependencies it can provide.
The algorithm for doing this is simple.
Gradle will inspect the group and name for the projects in the included build and substitute project dependencies for any external dependency matching `${project.group}:${project.name}`.

[NOTE]
====
By default, substitutions are not registered for the _main_ build.

To make the (sub)projects of the main build addressable by `${project.group}:${project.name}`, you can tell Gradle to treat the main build like an included build by self-including it: `includeBuild(".")`.
====

There are cases when the default substitutions determined by Gradle are insufficient or must be corrected for a particular composite.
For these cases, explicitly declaring the substitutions for an included build is possible.

For example, a single-project build called `anonymous-library`, produces a Java utility library but does not declare a value for the group attribute:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/samples/build-organization/composite-builds/declared-substitution">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="samples/build-organization/composite-builds/declared-substitution/kotlin",files="anonymous-library/build.gradle.kts[]"]
include::sample[dir="samples/build-organization/composite-builds/declared-substitution/groovy",files="anonymous-library/build.gradle[]"]
====

When this build is included in a composite, it will attempt to substitute for the dependency module `undefined:anonymous-library` (`undefined` being the default value for `project.group`, and `anonymous-library` being the root project name).
Clearly, this isn't useful in a composite build.

To use the unpublished library in a composite build, you can explicitly declare the substitutions that it provides:

====
include::sample[dir="samples/build-organization/composite-builds/declared-substitution/kotlin",files="settings.gradle.kts[tags=composite_substitution]"]
include::sample[dir="samples/build-organization/composite-builds/declared-substitution/groovy",files="settings.gradle[tags=composite_substitution]"]
====

With this configuration, the `my-app` composite build will substitute any dependency on `org.sample:number-utils` with a dependency on the root project of `anonymous-library`.

IMPORTANT: Substitutions are not transitive across builds.

Explicitly declared substitutions are only active for the build that defines them.
In the example above, while `my-app` knows to substitute `org.sample:number-utils` with the local `anonymous-library`, the `anonymous-library` build itself remains unaware of this rule.

If you run a task directly from within the `anonymous-library` directory that requires `org.sample:number-utils` (for example, in its own test suite), the resolution will fail unless:

1. The substitution is also declared in the `settings.gradle(.kts)` of `anonymous-library`.
2. (Recommended) You align the group and `rootProject.name` of `anonymous-library` to match the expected coordinates, allowing Gradle's default auto-substitution to work in both directions.

[[deactivate_included_build_substitutions]]
=== Deactivate included build substitutions for a configuration

If you need to <<declaring_configurations.adoc#sec:resolvable-consumable-configs,resolve>> a published version of a module that is also available as part of an included build, you can deactivate the included build substitution rules on the link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[ResolutionStrategy] of the Configuration that is resolved.
This is necessary because the rules are globally applied in the build, and Gradle does not consider published versions during resolution by default.

For example, we create a separate `publishedRuntimeClasspath` configuration that gets resolved to the published versions of modules that also exist in one of the local builds.
This is done by deactivating global dependency substitution rules:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/snippets/dependencyManagement/customizingResolution-deactivateGlobalSubstitution">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="snippets/dependencyManagement/customizingResolution-deactivateGlobalSubstitution/kotlin",files="build.gradle.kts[tags=disableGlobalDependencySubstitutionRules]"]
include::sample[dir="snippets/dependencyManagement/customizingResolution-deactivateGlobalSubstitution/groovy",files="build.gradle[tags=disableGlobalDependencySubstitutionRules]"]
====

A use-case would be to compare published and locally built JAR files.

[[included_build_substitution_requirements]]
=== Cases where included build substitutions must be declared

Many builds will function automatically as an included build, without declared substitutions.
Here are some common cases where declared substitutions are required:

* When the `archivesBaseName` property is used to set the name of the published artifact.
* When a configuration other than `default` is published.
* When the `maven-publish` or `ivy-publish` plugins are used for publishing and the publication coordinates don't match `${project.group}:${project.name}`.
* When multiple publications are defined for a single project (e.g., a project that publishes two different libraries).

[[included_build_substitution_limitations]]
=== Cases where composite build substitutions won't work

Some builds won't function correctly when included in a composite, even when dependency substitutions are explicitly declared.
This limitation is because a substituted project dependency will always point to the `default` configuration of the target project.
Any time the artifacts and dependencies specified for the default configuration of a project don't match what is published to a repository, the composite build may exhibit different behavior.

Here are some cases where the published module metadata may be different from the project default configuration:

* When the `maven-publish` or `ivy-publish` plugins are used with custom logic in the publication block.
* When the `POM` or `ivy.xml` file is tweaked as part of publication.
* When a capability or a custom variant is only defined via publication metadata.

Builds using these features may function incorrectly when included in a composite build.

[[included_build_task_dependencies]]
== Depending on Tasks in a Composite Build

While included builds are isolated from one another and cannot declare direct dependencies, a composite build can declare task dependencies on its included builds.
The included builds are accessed using link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds[Gradle.getIncludedBuilds()] or link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)[Gradle.includedBuild(java.lang.String)], and a task reference is obtained via the link:{groovyDslPath}/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task(java.lang.String)[IncludedBuild.task(java.lang.String)] method.

Using these APIs, it is possible to declare a dependency on a task in a particular included build:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/samples/build-organization/composite-builds/basic">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="build.gradle.kts[tags=run]"]
include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="build.gradle[tags=run]"]
====

Or you can declare a dependency on tasks with a certain path in some or all of the included builds:

++++
<div style="text-align: right;">
  <a href="https://github.com/gradle/gradle/tree/master/platforms/documentation/docs/src/samples/build-organization/composite-builds/hierarchical-multirepo">
    <img src="https://img.shields.io/badge/View%20full%20project-GitHub-blue?logo=github&style=flat" alt="View full sample project on GitHub"/>
  </a>
</div>
++++

====
include::sample[dir="samples/build-organization/composite-builds/hierarchical-multirepo/kotlin",files="build.gradle.kts"]
include::sample[dir="samples/build-organization/composite-builds/hierarchical-multirepo/groovy",files="build.gradle"]
====
