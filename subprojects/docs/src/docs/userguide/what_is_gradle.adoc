// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[gradle_overview]]
[[what_is_gradle]]
= What is Gradle?

Gradle is an open-source https://en.wikipedia.org/wiki/Build_automation[build automation] tool
flexible enough to build almost any type of software. Gradle bases its design on the following fundamentals:

High performance::
Gradle avoids unnecessary work by only running tasks that need to run because inputs or outputs changed.
Gradle uses various caches to reuse outputs from previous runs. With a shared build cache, you can even reuse outputs across multiple machines.
JVM foundation::
Gradle runs on the JVM. This is a bonus for users familiar with Java, since build logic can use the standard Java APIs.
It also makes it easy to run Gradle on different platforms.
Conventions::
Gradle makes common types of projects easy to build through conventions. Plugins set sensible defaults to keep build scripts minimal.
But these conventions don't limit you: you can configure settings, add your own tasks, and make many other customizations in your builds.
Extensibility::
You can readily extend Gradle to provide your own build logic with custom tasks and plugins.
See Android builds for an example: they add many new build concepts such as flavors and build types.
IDE support::
Several major IDEs enable imports and interaction with Gradle builds, including Android Studio, IntelliJ IDEA, Eclipse, and NetBeans.
Gradle can also provides generate the solution files required to load a project into Visual Studio.
Insight::
https://scans.gradle.com/[Build scans] provide extensive information about a build that you can use to identify issues.
You can use build scans to identify problems with a build's performance, and even share them for debugging help.

== Concepts

It's helpful to know the following concepts before you dive into the details of Gradle.

=== Projects

Projects are the things that Gradle builds.
Projects contain a build script, named `build.gradle` or `build.gradle.kts`.
Builds scripts define tasks, dependencies, plugins, and other configuration for your build.
A single project can contain many subprojects, which can each contain their own subprojects.

=== Tasks

Tasks contain the logic that implements builds.
In most use cases, you'll use or extend existing tasks, like the built-in Java `test` task.
Gradle provides task implementations for many common build sytem goals, like running tests and creating archives.
Plugins provide even more task implementations.

Tasks themselves consist of:

 * Actions: pieces of work that do something, like copy files or compile source
 * Inputs: values, files and directories that the actions use or operate on
 * Outputs: files and directories that the actions modify or generate

=== Plugins

Plugins provide a means of reusing logic and configuration across multiple projects.
With plugins, you can write a task once and use it in multiple builds. Or you can store common configuration,
like logging, dependencies, and version management, in one place. This reduces duplication in
build scripts.

=== Builds

A build is an execution of a collection of tasks in a Gradle project. You instantiate a build with a Gradle command
via the CLI or an IDE. In the command, you specify a task or tasks. Gradle determines which tasks to run based
on inter-task dependencies, and runs the smallest set of tasks required to complete the specified task and its dependencies.

== Optimizations

Over the years, Gradle has engineered a number of ways to make your builds faster.
Gradle enables some of these, like the Daemon, by default. You must explicitly enable some other optimizations
through configuration or build logic. This section highlights some of the most important
optimizations to know about when you start using Gradle.

=== Configuration Cache

The configuration phase is a large up-front cost for all Gradle builds. Every time you build your project, Gradle
configures the project based on available inputs like build scripts, settings, and system properties. The
configuration cache allows Gradle to cache the result of this configuration. This can save significant time
in every build. However, the configuration cache is only compatible with certain syntax.

=== Build Cache

Every time you run a build, Gradle runs a set of tasks.
The build cache stores the inputs provided to and outputs generated by those tasks.
When you run Gradle with the build cache enabled, Gradle checks the inputs for each
task. If the build cache contains output for a repeated set of task inputs, Gradle reuses that output.
Gradle can speed up builds significantly by pulling data from the cache instead of running the same task repeatedly.
However, the build cache requires annotated inputs and outputs on tasks.

=== Script Design

Well-designed build scripts consist mostly of
<<authoring_maintainable_build_scripts#sec:avoid_imperative_logic_in_scripts,declarative configuration, rather than imperative logic>>.
That configuration runs during the configuration phase. Many builds also have task actions
— for example via `doLast {}` and `doFirst {}` blocks — which run during the execution phase.

It's easy to view Gradle's build scripts as executable code, because that's what they are.
But that's an implementation detail: well-designed build scripts describe _what_ steps build the software,
not _how_ those steps do the work. That's a job for custom task types and plugins.

== Build Phases

Gradle evaluates and executes build scripts in three *build phases* of the <<build_lifecycle#build_lifecycle,Build Lifecycle>>:

 1. Initialization
+
Sets up the environment for the build and determine which projects will take part in it.

 2. Configuration
+
Constructs and configures the task graph for the build. Determines which tasks need to run and in which order, based on the task the user wants to run.

 3. Execution
+
Runs the tasks selected at the end of the configuration phase.

[NOTE]
.Maven Phases and Gradle
====
Gradle's build phases are not like Maven's phases.
Maven uses phases to divide the build execution into multiple stages.
Maven phases serve a similar role to Gradle's task graph, although less flexibly.

Maven's concept of a build lifecycle is loosely similar to Gradle's <<base_plugin#sec:base_tasks,lifecycle tasks>>.
====
