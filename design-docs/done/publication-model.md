## Customising Ivy descriptor XML (DONE)

This initial step will provide some capability to modify the generated `ivy.xml` files before publication. It will introduce a new set of tasks for publishing
to repositories.

1. Introduce a `Publication` interface. Probably make `Publication` a `Named` thing.
2. Add a `Publication` container to the project. At this stage, this container will be _read-only_.
3. Add `IvyPublication` interface and `IvyModuleDescriptor` interface.
    * Has-a property called `descriptor` of type `IvyModuleDescriptor`.
4. Add an `ivy-publish` plugin that adds a single `IvyPublication` instance to the container.
5. When using this `IvyPublication` for publishing, the following defaults are used:
    * `organisation` == `project.group`
    * `module` == `project.name` (_not_ `archivesBaseName`)
    * `revision` == `project.version`
    * `status` == `project.status`
    * Only dependency declarations from public configurations are included, and no configuration extension is used.
    * All artifacts from public configurations are published.
6. Add an `IvyPublish` task type.
    * Has-a property called `publication` of type `IvyPublication`
    * Has-a property called `repository` of type `IvyArtifactRepository`
7. When the `ivy-publish` plugin is applied, a rule is added that will add a `publish${publication.name}` task of type `Publish` for each publicaton
   added to the publications container.
    * The `publication` property will be wired up to the publication
    * The `repository` property will be left unspecified.
8. When the `ivy-publish` plugin is applied, a lifecycle task called `publish` is added that dependsOn those tasks added by the above rule.
9. Add `IvyModuleDescriptor.withXml()` methods and wire this up to `ivy.xml` generation.

TBD - Add a `publishing` extension with repositories and publications

To publish an Ivy module:

    apply plugin: 'ivy-publish'

    publishing {
        repositories {
            ivy { ... }
        }
    }

Running `gradle publish` will build the artifacts and upload to the specified repository.

To customise the `ivy.xml`:

    apply plugin: 'ivy-publish'

    publishing {
        repositories.ivy { ... }

        publications.ivy.descriptor.withXml { xml -> ... }
    }

Another example, using rules:

    apply plugin: 'ivy-publish'

    publishing {
        repositories.ivy { ... }

        publications.withType(IvyPublication) {
            ivy.withXml { xml -> ... }
        }
    }

To publish to multiple repositories:

    apply plugin: 'ivy-publish'

    publishing {
        repositories {
            ivy { ... }
            ivy { ... }
        }
    }

Running `gradle publish` will publish the module to both repositories.

The `ivy-publish` plugin is intended to move Ivy concepts out of the core Gradle DSL, but still allow them to be available for customisation for those
projects that use Ivy. It also allows us to introduce some breaking changes, in an opt-in way.

Note: there are some breaking changes here when you apply the `ivy-publish` plugin:

* The project name rather than the `archivesBaseName` property is  used as the default Ivy module name.
* Only the dependency declarations and artifacts from public configurations are referenced in the generated Ivy descriptor and published to the
      repository.

Note that publishing multiple Ivy modules is not yet supported. This is covered by later stories.

### Implementation approach

The `IvyPublication` instance will need to be considered by `IvyBackedArtifactPublisher` when generating the Ivy descriptor. It might make sense
at this point to start pulling descriptor generation up, so that it can eventually be generated by a task.

### Test cases

* Basic test that running the `publish` task actually publishes something.
    * With java plugin
    * With no other plugins
* Multi-project build with project dependencies that is published to an Ivy repository can be successfully resolved by another build.
* A `withXml` action can be used to modify the generated `ivy.xml`.
* Decent error message when the `withXml` action fails.
* Descriptor contains non-ascii characters.

## Customising Maven descriptor XML (DONE)

This step will provide some capability to modify the generated `pom.xml` files before publication. It will introduce the ability to use the new
publication tasks to publish Maven modules.

1. Add `MavenPublication` interface and `MavenPom` interface.
    * A `MavenPublication` has-a property called `pom` of type `MavenPom`.
2. Add a `maven-publish` plugin. This plugin adds a single `MavenPublication` instance.
3. When this `MavenPublication` instance is used for publishing, the following defaults are used:
    * `groupId` == `project.group`
    * `artifactId` == `project.name` (_not_ `archivesBaseName`)
    * `version` == `project.version`
    * `packaging` == `null`
    * No dependencies are included in the pom.
    * All artifacts from public configurations are published.
4. Add a `PublishToMavenRepository` task.
5. Change the `maven` repository type to handle publishing a `MavenPublication`.
6. Add `Pom.withXml()` methods and wire these up to pom generation.
7. When the `maven-publish` plugin is applied, a rule is added to define a `PublishToMavenRepository` task instance for each `MavenPublication` and each publishing repository of
   type `MavenRepository`.
8. When the `maven-publish` plugin is applied, a rule is added to define a `publishLocal${publication.name}` task of type `MavenPublish` for each publication
   of type `MavenPublication` added to the publications container.
    * The `publication` property is wired up to the publication
    * The `repository` property defaults to `mavenLocal()`.
9. Update the "Ivy Publishing" chapter in the user guide to also describe how to publish to a Maven repository.

To publish a Maven module:

    apply plugin: 'maven-publish'

    repositories {
        maven { ... }
    }

Running `gradle publish` will build the artifacts and upload to the specified repository. Running `gradle publishMavenLocal` will build the artifacts and
copy them into the local Maven repository.

To customise the `pom.xml`:

    apply plugin: 'maven-publish'

    publishing {
        repositories.maven { ... }

        publications.maven.pom.withXml { xml -> ... }
    }

Or, using rules:

    apply plugin: 'maven-publish'

    publishing {
        repositories.maven { ... }

        publications.withType(MavenPublication) {
            pom.withXml { xml -> ... }
        }
    }

Publishing both an Ivy and Maven module:

    apply plugin: 'ivy-publish'
    apply plugin: 'maven-publish'

    publishing {
        repositories {
            ivy { ... }
            maven { ... }
        }
    }

Running `gradle publish` will build and upload both modules.

Note: there are some breaking changes here when you apply the `maven-publish` plugin:

* The project name rather than `archivesBaseName` property is used as the default Maven module artifactId.
* No dependencies are included in the generated `pom.xml`.
* Only artifacts from public configurations are included the publication.

Note that publishing multiple Maven modules is not yet supported. It is also not possible to add any dependencies to the pom (except via manipulating
the XML). These are covered by later stories.

### Implementation approach

It should be possible to implement this as an adapter over the existing MavenPom/MavenResolver infrastructure.

### Test cases

* Basic test that running the `publish` task publishes artifacts and the pom.
* A `withXml` action can be used to modify the generated `pom.xml`.
* Decent error message when the `withXml` action fails.
* Descriptor contains non-ascii characters.

## Allow Ivy module descriptor to be generated without publishing to a repository (DONE)

In this step, the meta-data file generation for an Ivy publication is moved out of the `publish` tasks and into a separate task.

1. Add `GenerateIvyDescriptor` task type. Takes a `IvyModuleDescriptor` as input and generates an `ivy.xml` from this.
2. The `ivy-publish` task adds a rule to define a `generate${publication}MetaData` task for each publication of type `IvyPublication` added to the
   publications container.
3. Remove the `file` property from `IvyModuleDescriptor`, and replace it with a `descriptorFile` property on `IvyPublication`.
4. Change `IvyModuleDescriptor` so that it no longer extends `Buildable`.
5. Change the `GenerateIvyDescriptor` task type to remove the `module` and `configurations` properties, and replace these with a `descriptor` property of
   type `IvyModuleDescriptor`.
6. Update user guide to mention how to generate the `ivy.xml` for a publication.

To generate the Ivy module descriptor:

    apply plugin: 'ivy-publish`

Running `gradle generateIvyMetaData` would generate the `ivy.xml` for the default Ivy publication for this project.

### Test cases

* Unignore IvyLocalPublishIntTest.canGenerateTheIvyXmlWithoutPublishing().

## Publish Java library to Maven repository with correct runtime dependencies (DONE)

This story introduces the concept of a component and the ability to publish components.

1. Introduce a `Component` interface that extends `Named` and add a `components` container to `Project`. This container will initially be _read-only_ from
   a user's point of view. Also add an associated `ComponentInternal` interface.
2. Change the Java plugin to add a `Component` instance called `java` to this container.
3. Change the Maven publish plugin so that it adds no publications by default.
4. Change the Maven publish plugin so that when the `java` component instance is defined:
    1. Adds a Maven publication called `maven`.
    2. Has (groupId, artifactId, version) identifier that defaults to (project.group, project.name, project.version).
    3. Includes dependencies declared in `configurations.runtime.allDependencies` in the generated POM. Add the appropriate methods to `ComponentInternal` to allow
       the component instance to specify which dependencies should be included so that the Maven publish plugin does not have any knowledge of the Java plugin.
    4. Publishes the JAR artifact only.

To publish a Java library to a Maven repository

    apply plugin: 'java'
    apply plugin: 'maven-publish'

    dependencies {
        compile 'group:libA:1.2'
        runtime 'group:libB:1.3'
    }

    publishing {
        repositories {
            maven { url '...' }
        }
    }

Running `gradle publish` will publish the JAR and POM to the repository.

### Test cases

- Run `gradle publish` for a project with just the `maven-publish` plugin applied. Verify nothing is published.
- Run `gradle assemble` for a Java project. Verify that the JAR is built.
- Publish a Java project with compile, runtime and testCompile dependencies. Verify only the compile and runtime dependencies are declared in the POM with runtime scope,
  and that only the JAR is uploaded. Verify that the packaging declared in the POM is `jar`.
- Publish multiple projects with the `java` plugin applied and project dependencies between the projects. Verify the POMs declares the appropriate dependencies.
- Add a cross version test that verifies that a Java library published to a Maven repository by the current Gradle version can be resolved by a previous Gradle version.
- Copy existing Maven publication tests for java libraries and rework to use `maven-publish` plugin.
- Publish a Java project to an HTTP repository. Verify that progress logging was generated.
## Publish Web application to Maven repository

This story adds a second type of component and a DSL to define which components are published.

1. Allow `MavenPublication` instances to be added to the publications container.
    - Default the publication's (groupId, artifactId, version) to (project.group, project.name, project.version).
2. Allow zero or one components to be added to a Maven publication.
3. Change the `maven-publish` plugin so that it does not create any publications by default.
4. Change the `war` plugin to add a component called `web`. When this component is added to a publication, the WAR artifact (only) is added to the publication.
5. Fix publishing a Maven publication with no artifacts.

To publish a Java library

    apply plugin: 'java'
    apply plugin: 'maven-publish'

    publishing {
        repositories {
            maven { url '...' }
        }
        publications {
            myLib(MavenPublication) {
                from components.java
                pom.withXml { ... }
            }
        }
    }

To publish a Web application

    apply plugin: 'war'
    apply plugin: 'maven-publish'

    publishing {
        repositories {
            maven { url '...' }
        }
        publications {
            myWebApp(MavenPublication) {
                from components.web
            }
        }
    }

Note: there is a breaking change in this story, as nothing is published by default.

### Test cases

- Run `gradle assemble` for a web project. Verify that the WAR is built.
- Run `gradle publish` for a project that defines an empty publication. Verify that only a POM is uploaded and that the POM declares no dependencies.
- Run `gradle publish` for a web application that has compile, runtime and testRuntime dependencies. Verify that the WAR is uploaded and that no dependencies are declared
  in the generated POM. Verify that the packaging declared in the POM is `war`.
- Run `gradle publish` for a web application assembled from several other projects in the same build. Verify that the WAR is uploaded and that no dependencies are declared
  in the generated POM.
- Add a cross version test that verifies that a web application published to a Maven repository by the current Gradle version can be resolved by a previous Gradle version.
- Copy existing Maven publication tests for web applications and rework to use `maven-publish` plugin.

## Allow outgoing artifacts to be customised for Maven publications

This step allows the outgoing artifacts to be customised for a Maven publication.

1. Add a `MavenArtifact` interface with the following attributes:
    * `extension`
    * `classifier`
    * `file`
2. Add a `MavenArtifactSet` interface. This is a collection of `MavenArtifact` instances that permits access as a FileCollection.
3. Add `artifact` / `artifacts` methods to `MavenPublication`.
4. When publishing, validate that (extension, classifier) is unique for each artifact.
5. When publishing, validate that the artifact file exists and is a file.

To customise a Maven publication:

    apply plugin: 'maven-publish'

    publishing {
        publications {
            myLib(MavenPublication) {
                artifacts = [sourceJar, javadocJar]
                artifact file: distZip, classifier: 'dist'
                artifact documentationTask.outputFile {
                    classifier 'docs'
                    extension 'txt'
                }
            }
        }
    }

    publishing.publications.myLib.artifacts.each {
        ...
    }

The 'artifact' creation method will accept the following forms of input:
* A PublishArtifact, that will be adapted to MavenArtifact
* An AbstractArchiveTask, that will be adapted to MavenArtifact
* Anything that is valid input to Project.file()
* One of the previous 3, together with a configuration closure that permits setting of classifier, extension and builtBy properties.
* A map with 'source' entry, that is interpreted as per above. Additional entries for 'classifier' and 'extension' and 'builtBy'.

### Test cases

* Existing empty publication test: Verify empty `artifacts` collection.
* Existing publish 'java' & 'web' tests: Verify `artifacts` collection contains a single entry for published 'jar' or 'war'.
* Publish with java component, add source and javadoc jars as additional artifacts. Verify classifiers of additional artifacts.
* Run `gradle publish` with no component, and verify added artifacts:
    * Add custom artifact from AbstractArchiveTask
    * Add custom artifact from file
    * Add custom artifact from file that is task outputFile
    * All of the 3 above, with configuration closure to specify classifier/extension
    * Add custom artifact using file-map notation
    * Modify elements of artifacts collection after creation
* Run `gradle publish` where mainArtifact and custom artifacts specified via (file,classifier,extension)
    * Verify that extension is taken from file name by default, and can be overridden in DSL.
    * Verify that classifier is taken from file name by default, and can be overridden in DSL.
* Verify that `archivesBaseName` does not affect the published artifact names.
* Publish with java component. Verify that the publishing DSL can be used to update the classifier & exension of artifact taken from component.
    * `publishing.publications.myLib.mainArtifact.classifier = 'custom'`
* Verify that cannot publish in the following cases:
    * artifact whose file does not exist
    * artifact whose file is a directory
    * multiple artifacts have the same (extension, classifier)
* Verify can publish with empty classifier and/or extension
* Verify can publish artifacts with non-ascii extension and classifier

## Allow Maven POM to be generated without publishing to a repository

In this step, the POM generation for a publication is moved out of the `publish` tasks and into a separate task.

1. Add `GenerateMavenPom` task type. Takes a `MavenPom` instance and `destination` file as input. Generates a `pom.xml` from this.
2. The `maven-publish` task adds a rule to define a `generate${publication}Pom` task for each publication of type `MavenPublication` that is added to
   the publications container.
3. Update DSL docs for new task
4. Update user guide to mention how to generate the POM file for a publication

Running `gradle generateMavenPom` would generate the `pom.xml` for the default Maven publication.

### Test cases

* Integration test that specifies generated pom location, executes GenerateMavenPom task, validates pom file content, and checks that module is not published

## Publish Java libraries and web applications to Ivy repository (DONE)

1. Change the `ivy-publishing` plugin so that it no longer defines any publications.
2. Allow `IvyPublication` instances to be added to the publications container.
    - Default (organisation, module, revision) to (project.group, project.name, project.version)
3. Allow zero or one components to be added to an Ivy publication.
4. When publishing a java library, declare the runtime dependencies and the JAR artifact in the descriptor.
5. When publishing a web application, declare the WAR artifact in the descriptor.
6. Include a default configuration in the descriptor.

Note: there is a breaking change in this story.

### Test cases

* Run `gradle publish` for a project with just the `ivy-publish` plugin applied. Verify nothing is published.
* Publish a java project with compile, runtime and testCompile dependencies.
    * Verify that the jar artifact is included in the descriptor runtime configuration.
    * Verify only the compile and runtime dependencies are included in the descriptor runtime configuration.
* Publish a war project with compile, runtime, providedCompile, providedRuntime and testCompile dependencies.
    * Verify that the war artifact is published and included in the descriptor runtime configuration.
    * Verify that no dependencies are included in the descriptor.
* Publish multiple projects with the `java` or `war` plugin applied and project dependencies between the projects.
    * Verify descriptor files contain appropriate artifact and dependency declarations.
    * Verify that libraries and transitive dependencies can be successfully resolved from another build.
* Cross-version test that verifies a Java project published by the current version of Gradle can be consumed by a previous version of Gradle,
  and vice versa.

## Allow outgoing artifacts to be customised for Ivy publications (DONE)

1. Add an `IvyArtifact` interface with the following attributes:
    * `name`
    * `type`
    * `extension`
    * `file`
    * `conf`
    * `classifier`
2. Add an `IvyArtifactSet` interface. This is a collection of objects that can be converted to a collection of `IvyArtifact` instances.
3. Add an `IvyConfiguration` interface. Add a `configurations` container to `IvyModuleDescriptor`
4. Add an `artifacts` property to `IvyConfiguration`.
5. When publishing or generating the descriptor, validate that the (name, type, extension, classifier) attributes are unique for each artifact.
6. When publishing, validate that the artifact file exists and is a file.

To customise an Ivy publication:

    apply plugin: 'ivy-publish'

    publishing {
        publications {
            ivy {
                configurations {
                     runtime
                     distributions
                     other {
                        extend "runtime"
                     }
                }
                artifacts = [jar]
                artifact sourceJar {
                    conf 'other'
                }
                artifact file: distZip, type: 'java-library-distribution', conf: 'other,distributions'
            }
        }
    }

The 'artifact' creation method will accept the following forms of input:
* A PublishArtifact, that will be adapted to IvyArtifact
* An AbstractArchiveTask, that will be adapted to IvyArtifact
* Anything that is valid input to Project.file()
* Any of the previous 4, together with a configuration closure that permits setting of name, type, classifier, extension and builtBy properties
* A map with 'file' entry, that is interpreted as per Project.file(). Additional entries for 'name', 'type', 'extension', 'classifier' and 'builtBy'.

Configurations will be constructed with no value for 'visibility', 'description', 'transitive', or 'deprecated' attributes, and will inherit ivy defaults.
The configuration 'extends' attribute is a string value, not validated.

Artifacts will be constructed with no attribute for 'conf' unless explicitly specified.
This allows them to inherit the default ('*') in ivy.xml or take the default value from the parent <publications/> element.

### Test cases

* Verify that `archivesBaseName` does not affect the published artifact names.

